<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#059669" />
  <meta name="description" content="Treinador profissional de probabilidades de poker com estat√≠sticas avan√ßadas" />
  
  <!-- Apple PWA Meta Tags -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="PokerTrainer" />
  
  <title>Poker Probability Trainer - PWA Completo</title>
  
  <!-- Complete Styles -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1f2937, #059669);
      color: white;
      min-height: 100vh;
      padding: 10px;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .header {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 20px;
      text-align: center;
      backdrop-filter: blur(10px);
    }
    
    .mode-selector {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      gap: 6px;
      margin: 15px 0;
      flex-wrap: nowrap;
    }
    
    .mode-btn {
      background: #6b7280;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.3s;
      flex: 1;
      min-width: 50px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .mode-btn.active {
      background: #f59e0b;
      transform: scale(1.05);
    }
    
    .game-board {
      background: rgba(5, 150, 105, 0.2);
      padding: 25px;
      border-radius: 15px;
      margin-bottom: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .card {
      display: inline-block;
      background: white;
      color: black;
      padding: 12px 8px;
      margin: 3px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 16px;
      min-width: 45px;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .card:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
    }
    
    .card.red {
      color: #dc2626;
    }
    
    .card.hidden {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
      font-size: 18px;
    }
    
    .card.revealed {
      animation: flipCard 0.6s ease-in-out;
    }
    
    .card.dealing {
      animation: dealCard 0.8s ease-out;
    }
    
    .options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin: 20px 0;
    }
    
    .option-btn {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
      border: none;
      padding: 20px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }
    
    .option-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }
    
    .option-btn:hover::before {
      left: 100%;
    }
    
    .option-btn:hover {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
    }
    
    .option-btn.correct {
      background: linear-gradient(135deg, #16a34a, #15803d) !important;
      animation: correctPulse 1s infinite;
    }
    
    .option-btn.wrong {
      background: linear-gradient(135deg, #dc2626, #b91c1c) !important;
      animation: wrongShake 0.5s;
    }
    
    .option-btn:disabled {
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    .controls {
      display: grid;
      grid-template-columns: 2fr 1fr 1fr;
      gap: 8px;
      justify-content: stretch;
      margin: 20px 0;
      width: 100%;
    }
    
    .btn {
      background: linear-gradient(135deg, #059669, #047857);
      color: white;
      border: none;
      padding: 12px 8px;
      border-radius: 25px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(5, 150, 105, 0.3);
      font-size: 14px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .btn:hover {
      background: linear-gradient(135deg, #047857, #065f46);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(5, 150, 105, 0.4);
    }
    
    .btn.secondary {
      background: linear-gradient(135deg, #6b7280, #4b5563);
    }
    
    .btn.danger {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
    }
    
    .btn.phase-btn {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      font-size: 16px;
      padding: 15px 30px;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    
    .stat-card {
      background: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s;
    }
    
    .stat-card:hover {
      transform: translateY(-2px);
      background: rgba(0, 0, 0, 0.4);
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #f59e0b;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .progress-bar {
      width: 100%;
      height: 12px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      overflow: hidden;
      margin: 10px 0;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #f59e0b, #d97706);
      transition: width 0.8s ease;
      border-radius: 6px;
      position: relative;
    }
    
    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: progressShine 2s infinite;
    }
    
    .section {
      background: rgba(0, 0, 0, 0.2);
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
    }
    
    .hidden {
      display: none;
    }
    
    .tabs {
      display: flex;
      flex-direction: row;
      gap: 6px;
      margin-bottom: 20px;
      justify-content: space-between;
      flex-wrap: nowrap;
    }
    
    .tab {
      background: linear-gradient(135deg, #6b7280, #4b5563);
      color: white;
      border: none;
      padding: 10px 8px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 500;
      font-size: 12px;
      flex: 1;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .tab.active {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
    }
    
    .install-prompt {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: linear-gradient(135deg, #059669, #047857);
      color: white;
      border: none;
      padding: 15px 25px;
      border-radius: 25px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 8px 25px rgba(5, 150, 105, 0.4);
      z-index: 1000;
      animation: bounceIn 0.6s ease-out;
    }
    
    .achievement-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
      z-index: 1001;
      animation: slideInRight 0.5s ease-out;
      max-width: 300px;
    }
    
    .opponent-area {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
      margin: 20px 0;
    }
    
    .opponent-cards {
      text-align: center;
      background: rgba(0, 0, 0, 0.2);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s;
    }
    
    .opponent-cards.winner {
      border: 2px solid #16a34a;
      background: rgba(22, 163, 74, 0.1);
      animation: winnerGlow 2s infinite;
    }
    
    .opponent-name {
      font-size: 12px;
      margin-bottom: 8px;
      color: #9ca3af;
    }
    
    .hand-result {
      background: rgba(0, 0, 0, 0.4);
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      text-align: center;
      border: 2px solid;
      animation: resultFadeIn 0.6s ease-out;
    }
    
    .hand-result.winner {
      border-color: #16a34a;
      background: rgba(22, 163, 74, 0.1);
    }
    
    .hand-result.loser {
      border-color: #dc2626;
      background: rgba(220, 38, 38, 0.1);
    }
    
    .achievement-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    
    .achievement-card {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      border: 2px solid;
      transition: all 0.3s;
    }
    
    .achievement-card.unlocked {
      border-color: #f59e0b;
      background: rgba(245, 158, 11, 0.1);
    }
    
    .achievement-card.locked {
      border-color: #6b7280;
      opacity: 0.6;
    }
    
    .beginners-hints {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid #3b82f6;
      padding: 15px;
      border-radius: 10px;
      margin: 15px 0;
    }
    
    .chart-container {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
    }
    
    .simple-chart {
      display: flex;
      align-items: end;
      height: 200px;
      gap: 10px;
      padding: 20px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
    }
    
    .chart-bar {
      background: linear-gradient(to top, #3b82f6, #60a5fa);
      border-radius: 4px 4px 0 0;
      min-width: 30px;
      position: relative;
      transition: all 0.3s;
    }
    
    .chart-bar:hover {
      transform: scale(1.1);
      background: linear-gradient(to top, #2563eb, #3b82f6);
    }
    
    .chart-label {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: #9ca3af;
    }
    
    .tournament-info {
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid #f59e0b;
      padding: 15px;
      border-radius: 10px;
      margin: 15px 0;
      text-align: center;
    }
    
    .pot-info {
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 10px;
      margin: 15px 0;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .winner-announcement {
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      padding: 20px;
      border-radius: 15px;
      margin: 20px 0;
      animation: winnerPulse 2s infinite;
    }
    
    .winner-announcement.player-won {
      background: linear-gradient(135deg, #16a34a, #15803d);
      color: white;
    }
    
    .winner-announcement.opponent-won {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      color: white;
    }
    
    /* Animations */
    @keyframes correctPulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(22, 163, 74, 0.7); }
      50% { box-shadow: 0 0 0 15px rgba(22, 163, 74, 0); }
    }
    
    @keyframes wrongShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-8px); }
      75% { transform: translateX(8px); }
    }
    
    @keyframes flipCard {
      0% { transform: rotateY(0); }
      50% { transform: rotateY(90deg); }
      100% { transform: rotateY(0); }
    }
    
    @keyframes dealCard {
      0% { 
        transform: translateY(-100px) rotateZ(180deg); 
        opacity: 0; 
      }
      50% {
        transform: translateY(-20px) rotateZ(90deg);
        opacity: 0.7;
      }
      100% { 
        transform: translateY(0) rotateZ(0deg); 
        opacity: 1; 
      }
    }
    
    @keyframes bounceIn {
      0% { transform: scale(0.3) translateY(100px); opacity: 0; }
      50% { transform: scale(1.05) translateY(-10px); }
      70% { transform: scale(0.9) translateY(0); }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }
    
    @keyframes slideInRight {
      0% { transform: translateX(100%); opacity: 0; }
      100% { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes resultFadeIn {
      0% { opacity: 0; transform: scale(0.8); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    @keyframes progressShine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    @keyframes winnerGlow {
      0%, 100% { box-shadow: 0 0 0 0 rgba(22, 163, 74, 0.7); }
      50% { box-shadow: 0 0 0 10px rgba(22, 163, 74, 0); }
    }
    
    @keyframes winnerPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    /* FOR√áA LAYOUTS HORIZONTAIS GLOBALMENTE */
    @media (max-width: 1000px) {
      .mode-selector {
        display: flex !important;
        flex-direction: row !important;
        flex-wrap: nowrap !important;
        gap: 4px;
      }
      
      .tabs {
        display: flex !important;
        flex-direction: row !important;
        flex-wrap: nowrap !important;
        gap: 4px;
      }
      
      .controls {
        display: grid !important;
        grid-template-columns: 2fr 1fr 1fr !important;
        gap: 6px;
      }
      
      .opponent-area {
        display: grid !important;
        grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)) !important;
        gap: 6px;
      }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      body {
        padding: 5px;
      }
      
      .container {
        max-width: 100%;
      }
      
      .options {
        grid-template-columns: 1fr;
        gap: 10px;
      }
      
      .stats {
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }
      
      .controls {
        grid-template-columns: 2fr 1fr 1fr;
        gap: 8px;
        margin: 15px 0;
      }
      
      .btn {
        padding: 10px 8px;
        font-size: 12px;
      }
      
      .btn.phase-btn {
        font-size: 12px;
        padding: 10px 8px;
      }
      
      .tabs {
        gap: 4px;
        margin-bottom: 15px;
      }
      
      .tab {
        padding: 8px 6px;
        font-size: 10px;
        min-width: 70px;
        max-width: none;
        flex: 1;
      }
      
      .mode-selector {
        gap: 4px;
        margin: 10px 0;
      }
      
      .mode-btn {
        padding: 6px 8px;
        font-size: 9px;
        min-width: 55px;
        max-width: none;
        flex: 1;
      }
      
      .opponent-area {
        grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
        gap: 6px;
        margin: 15px 0;
      }
      
      .opponent-cards {
        padding: 6px;
        font-size: 11px;
      }
      
      .opponent-name {
        font-size: 9px;
        margin-bottom: 4px;
      }
      
      .card {
        font-size: 11px;
        min-width: 30px;
        padding: 6px 4px;
        margin: 1px;
      }
      
      .game-board {
        padding: 12px;
      }
      
      .stat-card {
        padding: 8px;
      }
      
      .stat-value {
        font-size: 16px;
      }
      
      .header {
        padding: 12px;
        margin-bottom: 15px;
      }
      
      .header h1 {
        font-size: 18px;
        margin-bottom: 5px;
      }
      
      .header p {
        font-size: 11px;
      }
      
      .section {
        padding: 12px;
        margin: 15px 0;
      }
      
      .progress-bar {
        margin: 10px 0;
        height: 10px;
      }
      
      .tournament-info,
      .beginners-hints {
        padding: 8px;
        margin: 8px 0;
        font-size: 11px;
      }
      
      #explanation {
        font-size: 11px;
        max-height: 180px;
        padding: 6px;
      }
      
      .achievement-grid {
        grid-template-columns: 1fr;
        gap: 8px;
      }
      
      .achievement-card {
        padding: 12px;
      }
      
      .simple-chart {
        height: 120px;
        padding: 8px;
      }
      
      .chart-container {
        padding: 12px;
      }
      
      .install-prompt {
        left: 10px;
        right: 10px;
        bottom: 10px;
        padding: 10px 15px;
        font-size: 12px;
      }
      
      .achievement-notification {
        left: 10px;
        right: 10px;
        top: 10px;
        padding: 10px 15px;
        font-size: 12px;
      }
      
      .winner-announcement {
        font-size: 18px;
        padding: 15px;
      }
      
      .hand-result {
        padding: 15px;
      }
      
      .option-btn {
        padding: 15px;
        font-size: 16px;
      }
    }
    
    /* Dark mode enhancements */
    @media (prefers-color-scheme: dark) {
      .card {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      }
    }
    
    /* Extra small devices */
    @media (max-width: 480px) {
      .stats {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }
      
      .stat-value {
        font-size: 14px;
      }
      
      .tab {
        font-size: 9px;
        padding: 6px 4px;
        min-width: 60px;
      }
      
      .mode-btn {
        font-size: 8px;
        padding: 4px 6px;
        min-width: 50px;
      }
      
      .opponent-area {
        grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
        gap: 4px;
      }
      
      .card {
        font-size: 10px;
        min-width: 28px;
        padding: 4px 2px;
      }
      
      .header h1 {
        font-size: 16px;
      }
      
      .header p {
        font-size: 10px;
      }
      
      .btn {
        font-size: 11px;
        padding: 8px 6px;
      }
      
      .controls {
        gap: 6px;
      }
      
      .game-board {
        padding: 8px;
      }
      
      .section {
        padding: 8px;
        margin: 10px 0;
      }
    }
    
    /* Print styles */
    @media print {
      .install-prompt,
      .achievement-notification {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üéØ Poker Probability Trainer</h1>
      <p>Treinador profissional de probabilidades com IA avan√ßada</p>
      
      <!-- Mode Selector -->
      <div class="mode-selector">
        <button class="mode-btn active" onclick="setGameMode('iniciante')">üéì In√≠cio</button>
        <button class="mode-btn" onclick="setGameMode('normal')">üéØ Normal</button>
        <button class="mode-btn" onclick="setGameMode('especialista')">üß† Expert</button>
        <button class="mode-btn" onclick="setGameMode('torneio')">üèÜ Torneio</button>
        <button class="mode-btn" onclick="setGameMode('cenario')">üìö Cen√°rio</button>
      </div>
    </div>
    
    <!-- Navigation Tabs -->
    <div class="tabs">
      <button class="tab active" onclick="showTab('game')">üéÆ Jogo</button>
      <button class="tab" onclick="showTab('stats')">üìä Stats</button>
      <button class="tab" onclick="showTab('history')">üìù Hist√≥rico</button>
      <button class="tab" onclick="showTab('achievements')">üèÜ Trof√©us</button>
      <button class="tab" onclick="showTab('ranking')">üèÖ Ranking</button>
    </div>
    
    <!-- Game Tab -->
    <div id="game-tab" class="tab-content">
      <!-- Tournament Info -->
      <div id="tournament-info" class="tournament-info hidden">
        <div>üí∞ Stack: <span id="stack-size">1000</span> | üëÅÔ∏è Blind Level: <span id="blind-level">1</span> | üèÜ Pot: <span id="pot-size">150</span></div>
      </div>
      
      <!-- Beginner Hints -->
      <div id="beginners-hints" class="beginners-hints hidden">
        <h4>üí° Dicas para Iniciante:</h4>
        <div id="hint-content"></div>
      </div>
      
      <!-- Stats Display -->
      <div class="stats">
        <div class="stat-card">
          <div class="stat-value" id="score">0/0</div>
          <div>Acertos</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="accuracy">0%</div>
          <div>Precis√£o</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="streak">0</div>
          <div>Sequ√™ncia</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="hand-count">1/50</div>
          <div>M√£o</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="phase-display">Pr√©-Flop</div>
          <div>Fase</div>
        </div>
      </div>
      
      <!-- Progress Bar -->
      <div class="progress-bar">
        <div class="progress-fill" id="progress" style="width: 2%;"></div>
      </div>
      
      <!-- Game Board -->
      <div class="game-board">
        <div style="text-align: center; margin-bottom: 30px;">
          <h3>üÉè Mesa Comunit√°ria</h3>
          <div id="community-cards">
            <span style="color: #9ca3af;">Aguardando o flop...</span>
          </div>
        </div>
        
        <div style="text-align: center; margin-bottom: 30px;">
          <h3>üé≤ Suas Cartas</h3>
          <div id="player-cards"></div>
          <div id="hand-strength" style="margin-top: 10px; color: #f59e0b; font-weight: bold;"></div>
        </div>
        
        <div style="text-align: center;">
          <h3 id="opponents-title">üë• Oponentes (3)</h3>
          <div class="opponent-area" id="opponent-cards"></div>
        </div>
      </div>
      
      <!-- Winner Announcement -->
      <div id="winner-announcement" class="winner-announcement hidden">
        <div id="winner-text"></div>
        <div id="winning-hand-name" style="font-size: 18px; margin-top: 10px;"></div>
      </div>
      
      <!-- Hand Result Display -->
      <div id="hand-result" class="hand-result hidden">
        <div id="result-title"></div>
        <div id="winner-hand" style="margin: 15px 0;"></div>
        <div id="winner-cards"></div>
        <button class="btn" onclick="continueToNextHand()">‚û°Ô∏è Pr√≥xima M√£o</button>
      </div>
      
      <!-- Question Section -->
      <div class="section" id="question-section">
        <h2 style="text-align: center; margin-bottom: 20px;">
          ü§î Qual a probabilidade de voc√™ ganhar esta m√£o?
        </h2>
        <div class="options" id="options"></div>
        <div class="controls">
          <button class="btn phase-btn" id="phase-button" onclick="advancePhase()">üéØ Ver Flop</button>
          <button class="btn danger" onclick="foldHand()">üö´ Fold</button>
          <button class="btn secondary" onclick="resetCurrentGame()">üîÑ Reset</button>
        </div>
        <div id="result-section" class="hidden" style="text-align: center; margin-top: 20px;">
          <div id="result-message"></div>
          <div id="correct-answer" style="margin: 10px 0;"></div>
          <div id="explanation" style="margin: 10px 0; font-size: 14px; color: #9ca3af; max-height: 300px; overflow-y: auto; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);"></div>
          <button class="btn" id="next-button" onclick="advancePhase()">‚û°Ô∏è Continuar</button>
        </div>
      </div>
    </div>
    
    <!-- Stats Tab -->
    <div id="stats-tab" class="tab-content hidden">
      <div class="section">
        <h2>üìä Estat√≠sticas Avan√ßadas</h2>
        <div class="stats">
          <div class="stat-card">
            <div class="stat-value" id="total-games">0</div>
            <div>Jogos Completos</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="best-streak">0</div>
            <div>Melhor Sequ√™ncia</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="total-folds">0</div>
            <div>Total de Folds</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="avg-accuracy">0%</div>
            <div>Precis√£o M√©dia</div>
          </div>
        </div>
        
        <!-- Phase Statistics Chart -->
        <div class="chart-container">
          <h3>üìà Precis√£o por Fase</h3>
          <div class="simple-chart" id="phase-chart"></div>
        </div>
        
        <!-- Hand Type Statistics -->
        <div class="chart-container">
          <h3>üÉè Performance por Tipo de M√£o</h3>
          <div id="hand-type-stats"></div>
        </div>
      </div>
    </div>
    
    <!-- History Tab -->
    <div id="history-tab" class="tab-content hidden">
      <div class="section">
        <h2>üìù Hist√≥rico Detalhado</h2>
        <div id="history-list">
          <p style="text-align: center; color: #9ca3af;">Jogue algumas m√£os para ver o hist√≥rico detalhado</p>
        </div>
      </div>
    </div>
    
    <!-- Achievements Tab -->
    <div id="achievements-tab" class="tab-content hidden">
      <div class="section">
        <h2>üèÜ Sistema de Conquistas</h2>
        <div class="achievement-grid" id="achievements-grid"></div>
      </div>
    </div>
    
    <!-- Ranking Tab -->
    <div id="ranking-tab" class="tab-content hidden">
      <div class="section">
        <h2>üèÖ Ranking Global</h2>
        <div id="ranking-list"></div>
        <div style="text-align: center; margin-top: 20px;">
          <button class="btn" onclick="resetPersonalStats()">üîÑ Reset Estat√≠sticas</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Install Button -->
  <button id="install-btn" class="install-prompt" style="display: none;">
    üì± Instalar App
  </button>
  
  <!-- Achievement Notification -->
  <div id="achievement-notification" class="achievement-notification" style="display: none;">
    <div style="font-weight: bold; margin-bottom: 5px;">üéâ Conquista Desbloqueada!</div>
    <div id="achievement-text"></div>
  </div>
  
  <script>
    // ======================
    // COMPLETE POKER TRAINER LOGIC WITH ALL FEATURES
    // ======================
    
    // Game State
    let gameState = {
      currentHand: 0, // Will be incremented to 1 on first completed hand
      score: { correct: 0, total: 0, folded: 0 },
      streak: 0,
      bestStreak: 0,
      totalGames: 0,
      phase: 'preflop',
      playerCards: [],
      communityCards: [],
      opponentCards: [],
      opponents: 3,
      currentProbability: 0,
      options: [],
      correctAnswer: 0,
      showingResult: false,
      showingHandResult: false,
      history: [],
      achievements: [],
      gameMode: 'iniciante',
      stackSize: 1000,
      blindLevel: 1,
      potSize: 150,
      phaseStats: {
        preflop: { correct: 0, total: 0 },
        flop: { correct: 0, total: 0 },
        turn: { correct: 0, total: 0 },
        river: { correct: 0, total: 0 }
      },
      handTypeStats: {},
      usedCards: [],
      handWinner: null,
      allPlayersHands: [],
      gameInProgress: false
    };
    
    // Card data and constants
    const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
    const values = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
    const suitColors = { '‚ô†': 'black', '‚ô•': 'red', '‚ô¶': 'red', '‚ô£': 'black' };
    
    const phaseNames = {
      'preflop': 'Pr√©-Flop',
      'flop': 'Flop',
      'turn': 'Turn',
      'river': 'River'
    };
    
    const nextPhaseText = {
      'preflop': 'üéØ Ver Flop',
      'flop': 'üéØ Ver Turn', 
      'turn': 'üéØ Ver River',
      'river': 'üèÜ Ver Vencedor'
    };
    
    const achievementsList = [
      { id: 'first_win', name: 'Primeira Vit√≥ria', description: 'Acerte sua primeira probabilidade', icon: 'üéØ' },
      { id: 'streak_5', name: 'Sequ√™ncia de 5', description: '5 acertos consecutivos', icon: 'üî•' },
      { id: 'streak_10', name: 'Ace High', description: '10 acertos consecutivos', icon: 'üèÜ' },
      { id: 'folder', name: 'Sele√ß√£o Criteriosa', description: 'Fa√ßa fold em 10 m√£os', icon: 'üö´' },
      { id: 'river_master', name: 'River Master', description: 'Acerte 10 probabilidades no river', icon: 'üåä' },
      { id: 'perfectionist', name: 'Perfeccionista', description: '95% de precis√£o em 20 perguntas', icon: 'üíé' },
      { id: 'analyzer', name: 'Analista', description: 'Responda 50 probabilidades', icon: 'üìä' },
      { id: 'tournament_player', name: 'Jogador de Torneio', description: 'Responda 10 probabilidades no modo torneio', icon: 'üèÜ' },
      { id: 'expert_mode', name: 'Modo Especialista', description: 'Responda 50 probabilidades no modo especialista', icon: 'üß†' },
      { id: 'poker_master', name: 'Mestre do Poker', description: '90% de precis√£o em 30 perguntas', icon: 'üëë' }
    ];
    
    const rankings = [
      { name: "PokerPro", score: 85.2, games: 12 },
      { name: "CardShark", score: 82.7, games: 8 },
      { name: "BluffMaster", score: 79.3, games: 15 },
      { name: "AceHunter", score: 76.8, games: 6 },
      { name: "RiverRat", score: 74.5, games: 10 }
    ];
    
    // Utility functions
    function shuffle(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }
    
    function createDeck() {
      const deck = [];
      for (let suit of suits) {
        for (let value of values) {
          deck.push({ value, suit });
        }
      }
      return deck;
    }
    
    function getCardValue(value) {
      if (value === 'A') return 14;
      if (value === 'K') return 13;
      if (value === 'Q') return 12;
      if (value === 'J') return 11;
      if (value === 'T') return 10;
      return parseInt(value);
    }
    
    function isStraight(cards) {
      if (cards.length < 5) return false;
      const values = cards.map(card => getCardValue(card.value)).sort((a, b) => a - b);
      const uniqueValues = [...new Set(values)];
      
      for (let i = 0; i <= uniqueValues.length - 5; i++) {
        let consecutive = 1;
        for (let j = i + 1; j < uniqueValues.length; j++) {
          if (uniqueValues[j] === uniqueValues[j-1] + 1) {
            consecutive++;
            if (consecutive === 5) return true;
          } else {
            break;
          }
        }
      }
      
      // Check for A-2-3-4-5 (wheel)
      if (uniqueValues.includes(14) && uniqueValues.includes(2) && uniqueValues.includes(3) && 
          uniqueValues.includes(4) && uniqueValues.includes(5)) {
        return true;
      }
      
      return false;
    }
    
    function evaluateHand(playerCards, communityCards) {
      const allCards = [...playerCards, ...communityCards];
      if (allCards.length < 2) return { rank: 0, score: 0, name: 'Carta Alta', cards: [] };

      const values = allCards.map(card => getCardValue(card.value));
      const suits = allCards.map(card => card.suit);
      const valueCounts = {};
      const suitCounts = {};

      values.forEach(value => valueCounts[value] = (valueCounts[value] || 0) + 1);
      suits.forEach(suit => suitCounts[suit] = (suitCounts[suit] || 0) + 1);

      const counts = Object.values(valueCounts).sort((a, b) => b - a);
      const isFlush = Object.values(suitCounts).some(count => count >= 5);
      const straight = isStraight(allCards);
      const highCard = Math.max(...values);

      if (allCards.length >= 5) {
        if (isFlush && straight && values.includes(14) && values.includes(13)) 
          return { rank: 10, score: 1000 + highCard, name: 'Royal Flush', cards: allCards };
        if (isFlush && straight) 
          return { rank: 9, score: 900 + highCard, name: 'Straight Flush', cards: allCards };
        if (counts[0] === 4) 
          return { rank: 8, score: 800 + highCard, name: 'Quadra', cards: allCards };
        if (counts[0] === 3 && counts[1] === 2) 
          return { rank: 7, score: 700 + highCard, name: 'Full House', cards: allCards };
        if (isFlush) 
          return { rank: 6, score: 600 + highCard, name: 'Flush', cards: allCards };
        if (straight) 
          return { rank: 5, score: 500 + highCard, name: 'Sequ√™ncia', cards: allCards };
        if (counts[0] === 3) 
          return { rank: 4, score: 400 + highCard, name: 'Trinca', cards: allCards };
        if (counts[0] === 2 && counts[1] === 2) 
          return { rank: 3, score: 300 + highCard, name: 'Dois Pares', cards: allCards };
        if (counts[0] === 2) 
          return { rank: 2, score: 200 + highCard, name: 'Um Par', cards: allCards };
      }
      
      return { rank: 1, score: highCard, name: 'Carta Alta', cards: allCards };
    }
    
    function calculateAdvancedProbability(playerCards, communityCards, opponents) {
      // Use professional blocker and outs analysis
      if (gameState.phase === 'preflop') {
        return calculatePreflopEquityWithBlockers(playerCards, opponents);
      } else {
        return calculatePostflopWithSimulation(playerCards, communityCards, opponents);
      }
    }
    
    function calculatePreflopEquityWithBlockers(playerCards, opponents) {
      const card1 = getCardValue(playerCards[0].value);
      const card2 = getCardValue(playerCards[1].value);
      const suit1 = playerCards[0].suit;
      const suit2 = playerCards[1].suit;
      
      const isPair = card1 === card2;
      const isSuited = suit1 === suit2;
      const highCard = Math.max(card1, card2);
      const lowCard = Math.min(card1, card2);
      
      let baseEquity = 0;
      
      // Base equity from preflop charts
      if (isPair) {
        if (card1 >= 14) baseEquity = 0.85;      // AA
        else if (card1 >= 13) baseEquity = 0.82;  // KK  
        else if (card1 >= 12) baseEquity = 0.80;  // QQ
        else if (card1 >= 11) baseEquity = 0.78;  // JJ
        else if (card1 >= 10) baseEquity = 0.75;  // TT
        else if (card1 >= 9) baseEquity = 0.72;   // 99
        else if (card1 >= 8) baseEquity = 0.69;   // 88
        else if (card1 >= 7) baseEquity = 0.66;   // 77
        else if (card1 >= 6) baseEquity = 0.63;   // 66
        else if (card1 >= 5) baseEquity = 0.60;   // 55
        else if (card1 >= 4) baseEquity = 0.57;   // 44
        else if (card1 >= 3) baseEquity = 0.54;   // 33
        else baseEquity = 0.51;                   // 22
      }
      else if (highCard >= 14 && lowCard >= 13) {
        baseEquity = isSuited ? 0.65 : 0.60;     // AK
      }
      else if (highCard >= 14 && lowCard >= 12) {
        baseEquity = isSuited ? 0.62 : 0.57;     // AQ
      }
      else if (highCard >= 14 && lowCard >= 11) {
        baseEquity = isSuited ? 0.59 : 0.54;     // AJ
      }
      else if (highCard >= 14 && lowCard >= 10) {
        baseEquity = isSuited ? 0.56 : 0.51;     // AT
      }
      else if (highCard >= 13 && lowCard >= 12) {
        baseEquity = isSuited ? 0.58 : 0.53;     // KQ
      }
      else if (highCard >= 13 && lowCard >= 11) {
        baseEquity = isSuited ? 0.55 : 0.50;     // KJ
      }
      else if (highCard >= 13 && lowCard >= 10) {
        baseEquity = isSuited ? 0.52 : 0.47;     // KT
      }
      else if (highCard >= 12 && lowCard >= 11) {
        baseEquity = isSuited ? 0.52 : 0.47;     // QJ
      }
      else if (highCard >= 12 && lowCard >= 10) {
        baseEquity = isSuited ? 0.49 : 0.44;     // QT
      }
      else if (highCard >= 11 && lowCard >= 10) {
        baseEquity = isSuited ? 0.46 : 0.41;     // JT
      }
      else if (highCard >= 14) {
        if (isSuited) baseEquity = Math.max(0.35, 0.45 - ((highCard - lowCard) * 0.02));
        else baseEquity = Math.max(0.30, 0.40 - ((highCard - lowCard) * 0.02));
      }
      else if (highCard >= 13) {
        if (isSuited) baseEquity = Math.max(0.30, 0.40 - ((highCard - lowCard) * 0.03));
        else baseEquity = Math.max(0.25, 0.35 - ((highCard - lowCard) * 0.03));
      }
      else if (highCard >= 11) {
        if (isSuited) baseEquity = Math.max(0.25, 0.35 - ((highCard - lowCard) * 0.03));
        else baseEquity = Math.max(0.20, 0.30 - ((highCard - lowCard) * 0.03));
      }
      else if ((highCard - lowCard) <= 1 && highCard >= 9) {
        baseEquity = isSuited ? 0.35 : 0.28;
      }
      else if ((highCard - lowCard) <= 2 && highCard >= 10 && isSuited) {
        baseEquity = 0.30;
      }
      else {
        if (isSuited) baseEquity = Math.max(0.15, 0.25 - ((highCard - lowCard) * 0.02));
        else baseEquity = Math.max(0.10, 0.20 - ((highCard - lowCard) * 0.02));
      }
      
      // Blocker adjustments for preflop
      let blockerBonus = 0;
      
      // Ace blocker reduces opponent AA/AK combos
      const hasAce = playerCards.some(c => getCardValue(c.value) === 14);
      if (hasAce) {
        blockerBonus += 0.02; // Slightly better against random range
      }
      
      // King blocker reduces opponent KK/AK combos  
      const hasKing = playerCards.some(c => getCardValue(c.value) === 13);
      if (hasKing && !hasAce) {
        blockerBonus += 0.015;
      }
      
      // Suited cards block opponent flush potential
      if (isSuited) {
        blockerBonus += 0.01;
      }
      
      baseEquity += blockerBonus;
      
      // Opponent adjustment
      const opponentAdjustment = {
        1: 1.0, 2: 0.85, 3: 0.75, 4: 0.68, 5: 0.62,
        6: 0.57, 7: 0.53, 8: 0.49, 9: 0.46
      };
      
      const adjustment = opponentAdjustment[Math.min(opponents, 9)] || 0.40;
      return Math.max(0.05, Math.min(0.95, baseEquity * adjustment));
    }
    
    function calculatePostflopWithSimulation(playerCards, communityCards, opponents) {
      // Get all known cards
      const knownCards = [...playerCards, ...communityCards];
      const remainingDeck = getRemainingDeck(knownCards);
      
      // Calculate current hand strength
      const currentHand = evaluateHand(playerCards, communityCards);
      
      // Calculate outs and blockers
      const outsAnalysis = calculateOutsWithBlockers(playerCards, communityCards, remainingDeck);
      const blockerAnalysis = calculateBlockers(playerCards, communityCards);
      
      // Simulate remaining cards if not river
      if (gameState.phase === 'river') {
        // River: calculate exact equity vs random opponent hands
        return calculateRiverEquity(playerCards, communityCards, opponents, blockerAnalysis);
      } else {
        // Pre-river: simulate all possible runouts
        return simulateRunouts(playerCards, communityCards, remainingDeck, opponents, outsAnalysis, blockerAnalysis);
      }
    }
    
    function getRemainingDeck(usedCards) {
      const fullDeck = [];
      for (let suit of suits) {
        for (let value of values) {
          fullDeck.push({ value, suit });
        }
      }
      
      return fullDeck.filter(card => 
        !usedCards.some(used => used.value === card.value && used.suit === card.suit)
      );
    }
    
    function calculateOutsWithBlockers(playerCards, communityCards, remainingDeck) {
      const allCards = [...playerCards, ...communityCards];
      const playerValues = playerCards.map(c => getCardValue(c.value));
      const playerSuits = playerCards.map(c => c.suit);
      
      let flushOuts = 0;
      let straightOuts = 0;
      let pairOuts = 0;
      let twoPairOuts = 0;
      let tripsOuts = 0;
      let fullHouseOuts = 0;
      
      // Flush outs calculation with blockers
      const allSuits = allCards.map(c => c.suit);
      const suitCounts = {};
      allSuits.forEach(suit => suitCounts[suit] = (suitCounts[suit] || 0) + 1);
      
      Object.entries(suitCounts).forEach(([suit, count]) => {
        if (count === 4 && playerSuits.includes(suit)) {
          // Count remaining cards of this suit in deck
          flushOuts = remainingDeck.filter(card => card.suit === suit).length;
        }
      });
      
      // Straight outs calculation
      const allValues = allCards.map(c => getCardValue(c.value)).sort((a, b) => a - b);
      const uniqueValues = [...new Set(allValues)];
      
      // Check for open-ended straight draws
      for (let i = 0; i <= uniqueValues.length - 4; i++) {
        const sequence = uniqueValues.slice(i, i + 4);
        const isConsecutive = sequence.every((val, idx) => 
          idx === 0 || val === sequence[idx - 1] + 1
        );
        
        if (isConsecutive) {
          const playerContributes = playerValues.some(pv => sequence.includes(pv));
          if (playerContributes) {
            // Count available cards for straight completion
            const lowEnd = sequence[0] - 1;
            const highEnd = sequence[3] + 1;
            
            const lowCards = remainingDeck.filter(c => getCardValue(c.value) === lowEnd).length;
            const highCards = remainingDeck.filter(c => getCardValue(c.value) === highEnd).length;
            
            straightOuts = Math.max(straightOuts, lowCards + highCards);
          }
        }
      }
      
      // Inside straight (gutshot) calculation
      if (straightOuts === 0 && uniqueValues.length >= 3) {
        for (let i = 0; i < uniqueValues.length - 2; i++) {
          const gap = uniqueValues[i + 2] - uniqueValues[i];
          if (gap === 4) { // One card missing in the middle
            const missingValue = uniqueValues[i] + 2;
            const availableCards = remainingDeck.filter(c => getCardValue(c.value) === missingValue).length;
            straightOuts = Math.max(straightOuts, availableCards);
          }
        }
      }
      
      // Pair, two pair, trips outs
      const currentHand = evaluateHand(playerCards, communityCards);
      
      if (currentHand.rank === 1) { // High card
        // Outs to make a pair
        playerValues.forEach(pv => {
          const availableCards = remainingDeck.filter(c => getCardValue(c.value) === pv).length;
          pairOuts += availableCards;
        });
      }
      
      if (currentHand.rank === 2) { // One pair
        // Outs to two pair or trips
        const pairValue = getPairValue(playerCards, communityCards);
        
        // Trips outs
        tripsOuts = remainingDeck.filter(c => getCardValue(c.value) === pairValue).length;
        
        // Two pair outs
        const unpairedValues = playerValues.filter(pv => pv !== pairValue);
        unpairedValues.forEach(uv => {
          const availableCards = remainingDeck.filter(c => getCardValue(c.value) === uv).length;
          twoPairOuts += availableCards;
        });
      }
      
      if (currentHand.rank === 3) { // Two pair
        // Outs to full house
        const boardValues = communityCards.map(c => getCardValue(c.value));
        const valueCounts = {};
        [...playerValues, ...boardValues].forEach(v => {
          valueCounts[v] = (valueCounts[v] || 0) + 1;
        });
        
        Object.entries(valueCounts).forEach(([value, count]) => {
          if (count === 2) {
            const availableCards = remainingDeck.filter(c => getCardValue(c.value) === parseInt(value)).length;
            fullHouseOuts += availableCards;
          }
        });
      }
      
      if (currentHand.rank === 4) { // Trips
        // Outs to full house or quads
        const tripsValue = getTripValue(playerCards, communityCards);
        
        // Quads out
        const quadsOuts = remainingDeck.filter(c => getCardValue(c.value) === tripsValue).length;
        
        // Full house outs (pair any other card)
        const otherValues = [...new Set([...playerValues, ...communityCards.map(c => getCardValue(c.value))])];
        otherValues.forEach(ov => {
          if (ov !== tripsValue) {
            const availableCards = remainingDeck.filter(c => getCardValue(c.value) === ov).length;
            if (availableCards >= 2) {
              fullHouseOuts += availableCards;
            }
          }
        });
        
        fullHouseOuts += quadsOuts;
      }
      
      // Remove overlapping outs (e.g., card that makes flush AND pair)
      const totalCleanOuts = Math.min(47, flushOuts + straightOuts + pairOuts + twoPairOuts + tripsOuts + fullHouseOuts);
      
      return {
        flush: flushOuts,
        straight: straightOuts,
        pair: pairOuts,
        twoPair: twoPairOuts,
        trips: tripsOuts,
        fullHouse: fullHouseOuts,
        total: totalCleanOuts
      };
    }
    
    function calculateBlockers(playerCards, communityCards) {
      const blockers = {
        flushBlockers: {},
        straightBlockers: 0,
        pairBlockers: {},
        premiumBlockers: 0
      };
      
      // Flush blockers
      playerCards.forEach(card => {
        const suit = card.suit;
        blockers.flushBlockers[suit] = (blockers.flushBlockers[suit] || 0) + 1;
      });
      
      // Premium card blockers (reduces opponent strong hands)
      playerCards.forEach(card => {
        const value = getCardValue(card.value);
        if (value >= 11) { // J, Q, K, A
          blockers.premiumBlockers++;
        }
      });
      
      // Pair blockers
      playerCards.forEach(card => {
        const value = getCardValue(card.value);
        blockers.pairBlockers[value] = (blockers.pairBlockers[value] || 0) + 1;
      });
      
      return blockers;
    }
    
    function calculateRiverEquity(playerCards, communityCards, opponents, blockers) {
      const playerHand = evaluateHand(playerCards, communityCards);
      const remainingDeck = getRemainingDeck([...playerCards, ...communityCards]);
      
      // Sample opponent hands and count wins
      let wins = 0;
      let totalSimulations = 1000; // Sample size for performance
      
      for (let sim = 0; sim < totalSimulations; sim++) {
        let playerWins = true;
        
        for (let opp = 0; opp < opponents; opp++) {
          // Deal random opponent hand
          const oppCards = shuffle(remainingDeck).slice(0, 2);
          const oppHand = evaluateHand(oppCards, communityCards);
          
          // Apply blocker adjustments (lower probability of premium hands)
          let oppHandAdjusted = oppHand;
          if (blockers.premiumBlockers > 0 && oppHand.rank >= 6) {
            oppHandAdjusted.score *= 0.95; // Slightly reduce opponent premium hands
          }
          
          if (compareHands(oppHandAdjusted, playerHand) > 0) {
            playerWins = false;
            break;
          }
        }
        
        if (playerWins) wins++;
      }
      
      return Math.max(0.05, Math.min(0.95, wins / totalSimulations));
    }
    
    function simulateRunouts(playerCards, communityCards, remainingDeck, opponents, outs, blockers) {
      const cardsToComplete = gameState.phase === 'flop' ? 2 : 1;
      let totalWins = 0;
      let totalSimulations = 500; // Performance balance
      
      for (let sim = 0; sim < totalSimulations; sim++) {
        const shuffledDeck = shuffle([...remainingDeck]);
        const runout = shuffledDeck.slice(0, cardsToComplete);
        const finalBoard = [...communityCards, ...runout];
        
        const finalPlayerHand = evaluateHand(playerCards, finalBoard);
        
        // Check if player wins against random opponents
        let playerWins = true;
        const usedCards = [...playerCards, ...finalBoard];
        const oppDeck = shuffledDeck.slice(cardsToComplete);
        
        for (let opp = 0; opp < opponents; opp++) {
          const oppCards = oppDeck.slice(opp * 2, (opp * 2) + 2);
          if (oppCards.length < 2) break;
          
          const oppHand = evaluateHand(oppCards, finalBoard);
          
          if (compareHands(oppHand, finalPlayerHand) > 0) {
            playerWins = false;
            break;
          }
        }
        
        if (playerWins) totalWins++;
      }
      
      return Math.max(0.05, Math.min(0.95, totalWins / totalSimulations));
    }
    
    function compareHands(hand1, hand2) {
      if (hand1.rank !== hand2.rank) {
        return hand1.rank - hand2.rank;
      }
      return hand1.score - hand2.score;
    }
    
    function analyzePreflopBlockers() {
      const card1 = getCardValue(gameState.playerCards[0].value);
      const card2 = getCardValue(gameState.playerCards[1].value);
      const suit1 = gameState.playerCards[0].suit;
      const suit2 = gameState.playerCards[1].suit;
      
      let blockerText = '';
      
      // Ace blocker
      const hasAce = card1 === 14 || card2 === 14;
      if (hasAce) {
        blockerText += '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ √Ås bloqueado: Reduz combos de AA, AK, AQ dos oponentes</div>';
      }
      
      // King blocker
      const hasKing = card1 === 13 || card2 === 13;
      if (hasKing && !hasAce) {
        blockerText += '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ Rei bloqueado: Reduz combos de KK, KQ, AK dos oponentes</div>';
      }
      
      // Pocket pair blockers
      const isPair = card1 === card2;
      if (isPair) {
        const cardName = getCardName(card1);
        blockerText += `<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ Par de ${cardName}s: Reduz sets de ${cardName} dos oponentes</div>`;
      }
      
      // Suited blockers
      const isSuited = suit1 === suit2;
      if (isSuited) {
        blockerText += `<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ 2 cartas de ${suit1}: Reduz flush draws de ${suit1} dos oponentes</div>`;
      }
      
      // High cards blocker
      const premiumCards = [card1, card2].filter(c => c >= 11).length;
      if (premiumCards > 0 && !hasAce && !hasKing) {
        blockerText += `<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ ${premiumCards} carta(s) premium: Reduz m√£os fortes dos oponentes</div>`;
      }
      
      if (blockerText === '') {
        blockerText = '<div style="margin-left: 30px; color: #9ca3af;">‚Ä¢ Sem blockers significativos</div>';
      }
      
      return blockerText;
    }
    
    function getCardName(value) {
      const names = {
        14: '√Ås', 13: 'Rei', 12: 'Dama', 11: 'Valete', 10: 'Dez',
        9: 'Nove', 8: 'Oito', 7: 'Sete', 6: 'Seis', 5: 'Cinco',
        4: 'Quatro', 3: 'Tr√™s', 2: 'Dois'
      };
      return names[value] || value.toString();
    }
    
    function getExpertRecommendation(equity, phase) {
      let recommendation = '';
      const equityPercent = Math.round(equity * 100);
      
      if (phase === 'preflop') {
        if (equityPercent >= 70) {
          recommendation = '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ <strong>Raise/3-bet agressivo</strong> - M√£o premium</div>';
          recommendation += '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ Build o pot, voc√™ est√° na frente contra a maioria dos ranges</div>';
        } else if (equityPercent >= 55) {
          recommendation = '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ <strong>Raise para value</strong> - M√£o s√≥lida</div>';
          recommendation += '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ Boa para open-raise na maioria das posi√ß√µes</div>';
        } else if (equityPercent >= 45) {
          recommendation = '<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ <strong>Call ou fold</strong> dependendo da posi√ß√£o</div>';
          recommendation += '<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ Playable em posi√ß√£o, fold early position vs raise</div>';
        } else if (equityPercent >= 30) {
          recommendation = '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ <strong>Fold na maioria das situa√ß√µes</strong></div>';
          recommendation += '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ S√≥ jogue com odds impl√≠citas muito boas</div>';
        } else {
          recommendation = '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ <strong>Fold imediato</strong> - M√£o muito fraca</div>';
          recommendation += '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ N√£o tem equity suficiente para ser lucrativa</div>';
        }
      } else {
        // Post-flop recommendations
        if (equityPercent >= 80) {
          recommendation = '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ <strong>Bet/raise for value</strong> - M√£o monstro</div>';
          recommendation += '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ Build o pot ao m√°ximo, voc√™ est√° dominando</div>';
        } else if (equityPercent >= 65) {
          recommendation = '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ <strong>Bet for value</strong> - M√£o forte</div>';
          recommendation += '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ Continue apostando para extrair valor</div>';
        } else if (equityPercent >= 50) {
          recommendation = '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ <strong>Bet or check-call</strong> - Ligeiramente na frente</div>';
          recommendation += '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ Pode apostar thin value ou controlar o pot</div>';
        } else if (equityPercent >= 35) {
          recommendation = '<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ <strong>Check-call ou fold</strong> - Equity marginal</div>';
          recommendation += '<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ Depende dos outs e pot odds</div>';
        } else {
          recommendation = '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ <strong>Check-fold</strong> - Equity baixa</div>';
          recommendation += '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ S√≥ continue com pot odds muito favor√°veis</div>';
        }
      }
      
      return recommendation;
    }
    
    function getOpponentImpactDescription(opponents) {
      let impactText = '';
      
      if (opponents === 1) {
        impactText = '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ Heads-up: Sua equity √© maximizada</div>';
        impactText += '<div style="margin-left: 30px;">‚Ä¢ Qualquer par ou carta alta pode ser suficiente</div>';
      } else if (opponents === 2) {
        impactText = '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ 3-way: Ainda boa situa√ß√£o</div>';
        impactText += '<div style="margin-left: 30px;">‚Ä¢ M√£os m√©dias ainda t√™m valor</div>';
      } else if (opponents <= 4) {
        impactText = '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ Mesa m√©dia: Equity reduzida moderadamente</div>';
        impactText += '<div style="margin-left: 30px;">‚Ä¢ Precisa de m√£os mais fortes para value bet</div>';
      } else if (opponents <= 6) {
        impactText = '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ Mesa cheia: Equity significativamente reduzida</div>';
        impactText += '<div style="margin-left: 30px;">‚Ä¢ Seja mais seletivo com suas jogadas</div>';
      } else {
        impactText = '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ Mesa muito cheia: Equity drasticamente reduzida</div>';
        impactText += '<div style="margin-left: 30px;">‚Ä¢ Jogue apenas m√£os premium</div>';
      }
      
      // Add reduction percentage
      const reductionPercent = Math.round((1 - getOpponentReduction(opponents)) * 100);
      if (reductionPercent > 0) {
        impactText += `<div style="margin-left: 30px; color: #9ca3af;">‚Ä¢ Redu√ß√£o de equity: ~${reductionPercent}% vs heads-up</div>`;
      }
      
      return impactText;
    }
    
    function getOpponentReduction(opponents) {
      const reductions = {
        1: 1.0, 2: 0.85, 3: 0.75, 4: 0.68, 5: 0.62,
        6: 0.57, 7: 0.53, 8: 0.49, 9: 0.46
      };
      return reductions[Math.min(opponents, 9)] || 0.40;
    }

    function getTripValue(playerCards, communityCards) {
      const allCards = [...playerCards, ...communityCards];
      const valueCounts = {};
      
      allCards.forEach(card => {
        const value = getCardValue(card.value);
        valueCounts[value] = (valueCounts[value] || 0) + 1;
      });
      
      for (let value = 14; value >= 2; value--) {
        if (valueCounts[value] >= 3) {
          return value;
        }
      }
      
      return 0;
    }
    

    

    
    function getPairValue(playerCards, communityCards) {
      const allCards = [...playerCards, ...communityCards];
      const valueCounts = {};
      
      allCards.forEach(card => {
        const value = getCardValue(card.value);
        valueCounts[value] = (valueCounts[value] || 0) + 1;
      });
      
      // Find the highest pair that includes a player card
      for (let value = 14; value >= 2; value--) {
        if (valueCounts[value] >= 2) {
          // Check if player contributed to this pair
          const playerHasThisValue = playerCards.some(pc => getCardValue(pc.value) === value);
          if (playerHasThisValue) {
            return value;
          }
        }
      }
      
      return 0; // No pair involving player cards
    }
    
    function generateOptions(correctProb) {
      const options = [correctProb];
      const range = gameState.gameMode === 'especialista' ? 0.08 : 0.15;
      
      while (options.length < 4) {
        const variation = (Math.random() - 0.5) * range * 2;
        const newOption = Math.max(0.05, Math.min(0.95, correctProb + variation));
        
        if (!options.some(opt => Math.abs(opt - newOption) < 0.03)) {
          options.push(newOption);
        }
      }
      
      return shuffle(options);
    }
    
    function renderCard(card, isHidden = false, shouldReveal = false, isDealing = false) {
      const colorClass = suitColors[card.suit] === 'red' ? 'red' : '';
      const hiddenClass = isHidden ? 'hidden' : '';
      const revealClass = shouldReveal ? 'revealed' : '';
      const dealClass = isDealing ? 'dealing' : '';
      
      return `<span class="card ${colorClass} ${hiddenClass} ${revealClass} ${dealClass}">
        ${isHidden ? 'üÇ†' : card.value + card.suit}
      </span>`;
    }
    
    function dealNewHand() {
      const deck = shuffle(createDeck());
      gameState.opponents = Math.floor(Math.random() * 6) + 2; // 2-7 opponents
      gameState.gameInProgress = true;
      
      // Deal player cards
      gameState.playerCards = deck.slice(0, 2);
      
      // Deal opponent cards
      gameState.opponentCards = [];
      gameState.allPlayersHands = [];
      let cardIndex = 2;
      
      for (let i = 0; i < gameState.opponents; i++) {
        const oppCards = deck.slice(cardIndex, cardIndex + 2);
        gameState.opponentCards.push(oppCards);
        gameState.allPlayersHands.push({
          name: `Oponente ${i + 1}`,
          cards: oppCards,
          isPlayer: false
        });
        cardIndex += 2;
      }
      
      // Add player to all hands
      gameState.allPlayersHands.unshift({
        name: 'Voc√™',
        cards: gameState.playerCards,
        isPlayer: true
      });
      
      gameState.usedCards = [...gameState.playerCards, ...gameState.opponentCards.flat()];
      gameState.communityCards = [];
      gameState.phase = 'preflop';
      gameState.showingResult = false;
      gameState.showingHandResult = false;
      gameState.handWinner = null;
      
      // Tournament mode adjustments
      if (gameState.gameMode === 'torneio') {
        if (gameState.currentHand > 0 && gameState.currentHand % 10 === 0) {
          gameState.blindLevel++;
        }
        gameState.potSize = gameState.blindLevel * 50 + (gameState.opponents * 25);
      }
      
      gameState.currentProbability = calculateAdvancedProbability(
        gameState.playerCards, 
        gameState.communityCards, 
        gameState.opponents
      );
      
      gameState.correctAnswer = gameState.currentProbability;
      gameState.options = generateOptions(gameState.currentProbability);
      
      updateDisplay();
      updateBeginnerHints();
      updatePhaseButton();
    }
    
    function updatePhaseButton() {
      const phaseBtn = document.getElementById('phase-button');
      phaseBtn.textContent = nextPhaseText[gameState.phase];
      phaseBtn.style.display = gameState.showingResult ? 'none' : 'block';
    }
    
    function updateBeginnerHints() {
      const hintsContainer = document.getElementById('beginners-hints');
      const hintContent = document.getElementById('hint-content');
      
      if (gameState.gameMode !== 'iniciante') {
        hintsContainer.classList.add('hidden');
        return;
      }
      
      hintsContainer.classList.remove('hidden');
      const hand = evaluateHand(gameState.playerCards, gameState.communityCards);
      const hints = [];
      
      if (hand.rank >= 7) hints.push("üî• M√£o muito forte - aposte com confian√ßa!");
      else if (hand.rank >= 4) hints.push("üí™ M√£o boa - voc√™ tem chances!");
      else if (hand.rank >= 2) hints.push("‚ö†Ô∏è M√£o m√©dia - cuidado com muitos oponentes");
      else hints.push("‚ùå M√£o fraca - considere fazer fold");
      
      // Pre-flop specific hints
      if (gameState.phase === 'preflop') {
        const card1 = getCardValue(gameState.playerCards[0].value);
        const card2 = getCardValue(gameState.playerCards[1].value);
        const isPair = card1 === card2;
        const isSuited = gameState.playerCards[0].suit === gameState.playerCards[1].suit;
        
        if (isPair && card1 >= 11) hints.push("üëë Par alto - excelente m√£o inicial!");
        else if (isPair) hints.push("üéØ Par - boa m√£o para ver o flop");
        if (isSuited) hints.push("üåà Cartas do mesmo naipe - potencial para flush");
      }
      
      // Check for draws after flop
      if (gameState.communityCards.length >= 3) {
        const allCards = [...gameState.playerCards, ...gameState.communityCards];
        const suits = allCards.map(c => c.suit);
        const suitCounts = {};
        suits.forEach(suit => suitCounts[suit] = (suitCounts[suit] || 0) + 1);
        
        const maxSuitCount = Math.max(...Object.values(suitCounts));
        if (maxSuitCount >= 4) {
          hints.push("üåä Draw para flush - voc√™ pode melhorar!");
        }
        
        // Check straight draw
        const values = allCards.map(c => getCardValue(c.value)).sort((a, b) => a - b);
        const uniqueValues = [...new Set(values)];
        if (uniqueValues.length >= 4) {
          let hasOpenEnded = false;
          for (let i = 0; i < uniqueValues.length - 3; i++) {
            const consecutive = uniqueValues.slice(i, i + 4).every((val, idx, arr) => 
              idx === 0 || val === arr[idx - 1] + 1
            );
            if (consecutive) hasOpenEnded = true;
          }
          if (hasOpenEnded) hints.push("üîÑ Draw para sequ√™ncia poss√≠vel!");
        }
      }
      
      hintContent.innerHTML = hints.map(hint => `<div>‚Ä¢ ${hint}</div>`).join('');
    }
    
    function updateDisplay() {
      // Update stats
      document.getElementById('score').textContent = 
        `${gameState.score.correct}/${gameState.score.total}`;
      
      const accuracy = gameState.score.total > 0 ? 
        Math.round((gameState.score.correct / gameState.score.total) * 100) : 0;
      document.getElementById('accuracy').textContent = `${accuracy}%`;
      
      document.getElementById('streak').textContent = gameState.streak;
      document.getElementById('hand-count').textContent = `${gameState.currentHand}/50`;
      document.getElementById('phase-display').textContent = phaseNames[gameState.phase];
      
      // Update progress
      const progress = Math.max(2, (gameState.currentHand / 50) * 100);
      document.getElementById('progress').style.width = `${progress}%`;
      
      // Update tournament info
      const tournamentInfo = document.getElementById('tournament-info');
      if (gameState.gameMode === 'torneio') {
        tournamentInfo.classList.remove('hidden');
        document.getElementById('stack-size').textContent = gameState.stackSize;
        document.getElementById('blind-level').textContent = gameState.blindLevel;
        document.getElementById('pot-size').textContent = gameState.potSize;
      } else {
        tournamentInfo.classList.add('hidden');
      }
      
      // Update cards with animations
      updatePlayerCards();
      updateCommunityCards();
      updateOpponentCards();
      
      // Show hand strength
      const handStrength = evaluateHand(gameState.playerCards, gameState.communityCards);
      document.getElementById('hand-strength').textContent = 
        `M√£o atual: ${handStrength.name}`;
      
      document.getElementById('opponents-title').textContent = 
        `üë• Oponentes (${gameState.opponents})`;
      
      // Update options
      if (!gameState.showingResult && !gameState.showingHandResult) {
        updateOptionsDisplay();
      }
      
      // Hide/show sections
      document.getElementById('result-section').classList.toggle('hidden', !gameState.showingResult);
      document.getElementById('hand-result').classList.toggle('hidden', !gameState.showingHandResult);
      document.getElementById('question-section').classList.toggle('hidden', gameState.showingHandResult);
      document.getElementById('winner-announcement').classList.toggle('hidden', !gameState.showingHandResult);
    }
    
    function updatePlayerCards() {
      const container = document.getElementById('player-cards');
      container.innerHTML = gameState.playerCards.map(card => renderCard(card)).join('');
    }
    
    function updateCommunityCards() {
      const container = document.getElementById('community-cards');
      if (gameState.communityCards.length === 0) {
        container.innerHTML = '<span style="color: #9ca3af;">Aguardando o flop...</span>';
      } else {
        container.innerHTML = gameState.communityCards.map((card, index) => {
          const isNew = (gameState.phase === 'flop' && index < 3) ||
                       (gameState.phase === 'turn' && index === 3) ||
                       (gameState.phase === 'river' && index === 4);
          return renderCard(card, false, false, isNew);
        }).join('');
      }
    }
    
    function updateOpponentCards() {
      const container = document.getElementById('opponent-cards');
      let opponentHTML = '';
      
      for (let i = 0; i < gameState.opponents; i++) {
        const isRevealed = gameState.showingHandResult;
        const oppCards = gameState.opponentCards[i] || [];
        const isWinner = gameState.handWinner && gameState.handWinner.name === `Oponente ${i + 1}`;
        
        opponentHTML += `
          <div class="opponent-cards ${isWinner ? 'winner' : ''}">
            <div class="opponent-name">Oponente ${i + 1}</div>
            <div>
              ${isRevealed && oppCards.length > 0 ? 
                oppCards.map(card => renderCard(card, false, true)).join('') :
                renderCard({ value: '?', suit: '?' }, true) + renderCard({ value: '?', suit: '?' }, true)
              }
            </div>
          </div>
        `;
      }
      container.innerHTML = opponentHTML;
    }
    
    function updateOptionsDisplay() {
      const optionsHTML = gameState.options.map((option, index) => {
        const percentage = Math.round(option * 100);
        return `<button class="option-btn" onclick="selectOption(${option})">${percentage}%</button>`;
      }).join('');
      
      document.getElementById('options').innerHTML = optionsHTML;
    }
    
    function selectOption(selectedOption) {
      if (gameState.showingResult) return;
      
      gameState.showingResult = true;
      const isCorrect = Math.abs(selectedOption - gameState.correctAnswer) < 0.01;
      
      // Update score
      gameState.score.total++;
      if (isCorrect) {
        gameState.score.correct++;
        gameState.streak++;
        gameState.bestStreak = Math.max(gameState.bestStreak, gameState.streak);
      } else {
        gameState.streak = 0;
      }
      
      // Update phase stats
      gameState.phaseStats[gameState.phase].total++;
      if (isCorrect) {
        gameState.phaseStats[gameState.phase].correct++;
      }
      
      // Update hand type stats
      const handType = evaluateHand(gameState.playerCards, gameState.communityCards).name;
      if (!gameState.handTypeStats[handType]) {
        gameState.handTypeStats[handType] = { correct: 0, total: 0 };
      }
      gameState.handTypeStats[handType].total++;
      if (isCorrect) {
        gameState.handTypeStats[handType].correct++;
      }
      
      // Add to history
      gameState.history.unshift({
        hand: gameState.currentHand,
        phase: gameState.phase,
        playerCards: [...gameState.playerCards],
        communityCards: [...gameState.communityCards],
        estimated: selectedOption,
        actual: gameState.correctAnswer,
        isCorrect: isCorrect,
        handType: handType,
        timestamp: new Date()
      });
      
      // Keep only last 50 hands
      if (gameState.history.length > 50) {
        gameState.history.pop();
      }
      
      // Check achievements
      checkAchievements(isCorrect);
      
      // Update option buttons
      const buttons = document.querySelectorAll('.option-btn');
      buttons.forEach((btn, index) => {
        btn.disabled = true;
        const optionValue = gameState.options[index];
        
        if (Math.abs(optionValue - gameState.correctAnswer) < 0.01) {
          btn.classList.add('correct');
        } else if (Math.abs(optionValue - selectedOption) < 0.01) {
          btn.classList.add('wrong');
        }
      });
      
      // Show result
      document.getElementById('result-message').innerHTML = isCorrect ? 
        '<span style="color: #16a34a; font-weight: bold; font-size: 18px;">‚úÖ Correto!</span>' :
        '<span style="color: #dc2626; font-weight: bold; font-size: 18px;">‚ùå Incorreto!</span>';
      
      document.getElementById('correct-answer').innerHTML = 
        `Probabilidade correta: <strong style="color: #f59e0b;">${Math.round(gameState.correctAnswer * 100)}%</strong>`;
      
      // Add detailed explanation - SIMPLIFIED VERSION
      let explanation = '';
      
      // Performance feedback
      const diff = Math.abs(selectedOption - gameState.correctAnswer);
      if (diff < 0.03) {
        explanation += '<div style="color: #16a34a; font-weight: bold; margin-bottom: 10px;">üéØ Excelente! Estimativa muito precisa!</div>';
      } else if (diff < 0.08) {
        explanation += '<div style="color: #f59e0b; font-weight: bold; margin-bottom: 10px;">üëç Boa estimativa! Pequena diferen√ßa.</div>';
      } else {
        explanation += '<div style="color: #dc2626; font-weight: bold; margin-bottom: 10px;">‚ö†Ô∏è Estimativa distante. Vamos analisar:</div>';
      }
      
      // Professional Analysis
      explanation += '<div style="margin: 15px 0 8px 0;"><strong>üî¨ An√°lise Profissional:</strong></div>';
      
      // 1. Blockers
      explanation += '<div style="margin-left: 15px; margin-bottom: 8px;"><strong>üõ°Ô∏è Blockers:</strong></div>';
      const card1 = getCardValue(gameState.playerCards[0].value);
      const card2 = getCardValue(gameState.playerCards[1].value);
      const hasAce = card1 === 14 || card2 === 14;
      const hasKing = card1 === 13 || card2 === 13;
      const isPair = card1 === card2;
      const isSuited = gameState.playerCards[0].suit === gameState.playerCards[1].suit;
      
      if (hasAce) {
        explanation += '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ √Ås bloqueado: Reduz AA, AK, AQ dos oponentes</div>';
      }
      if (hasKing && !hasAce) {
        explanation += '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ Rei bloqueado: Reduz KK, KQ, AK dos oponentes</div>';
      }
      if (isPair) {
        explanation += `<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ Par de ${getCardName(card1)}: Reduz sets dos oponentes</div>`;
      }
      if (isSuited) {
        explanation += `<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ 2 cartas de ${gameState.playerCards[0].suit}: Reduz flush draws</div>`;
      }
      if (!hasAce && !hasKing && !isPair && !isSuited) {
        explanation += '<div style="margin-left: 30px; color: #9ca3af;">‚Ä¢ Sem blockers significativos</div>';
      }
      
      // 2. Outs (post-flop only)
      if (gameState.communityCards.length >= 3) {
        explanation += '<div style="margin-left: 15px; margin-bottom: 8px; margin-top: 10px;"><strong>üéØ Outs Dispon√≠veis:</strong></div>';
        
        const currentHand = evaluateHand(gameState.playerCards, gameState.communityCards);
        let outsText = [];
        
        if (currentHand.rank === 1) { // High card
          outsText.push('6 outs para par');
        } else if (currentHand.rank === 2) { // One pair
          outsText.push('2 outs para trinca');
        } else if (currentHand.rank === 4) { // Trips
          outsText.push('1 out para quadra');
        }
        
        // Check flush draw
        const allCards = [...gameState.playerCards, ...gameState.communityCards];
        const suits = allCards.map(c => c.suit);
        const suitCounts = {};
        suits.forEach(suit => suitCounts[suit] = (suitCounts[suit] || 0) + 1);
        const maxSuit = Math.max(...Object.values(suitCounts));
        
        if (maxSuit === 4) {
          outsText.push('9 outs para flush');
        }
        
        if (outsText.length === 0) {
          explanation += '<div style="margin-left: 30px; color: #9ca3af;">‚Ä¢ Nenhum out direto para melhorar</div>';
        } else {
          outsText.forEach(out => {
            explanation += `<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ ${out}</div>`;
          });
        }
      }
      
      // 3. Expert Recommendation
      explanation += '<div style="margin-left: 15px; margin-bottom: 8px; margin-top: 10px;"><strong>üß† Recomenda√ß√£o dos Especialistas:</strong></div>';
      const equity = Math.round(gameState.correctAnswer * 100);
      
      if (equity >= 70) {
        explanation += '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ <strong>Raise/bet agressivo</strong> - M√£o premium</div>';
      } else if (equity >= 55) {
        explanation += '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ <strong>Bet for value</strong> - M√£o s√≥lida</div>';
      } else if (equity >= 45) {
        explanation += '<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ <strong>Call ou check</strong> - Situa√ß√£o marginal</div>';
      } else {
        explanation += '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ <strong>Check-fold</strong> - Equity baixa</div>';
      }
      
      // 4. Opponents
      explanation += '<div style="margin-left: 15px; margin-bottom: 8px; margin-top: 10px;"><strong>üë• Situa√ß√£o da Mesa:</strong></div>';
      explanation += `<div style="margin-left: 30px;">‚Ä¢ Voc√™ vs <strong>${gameState.opponents} oponentes</strong></div>`;
      
      if (gameState.opponents <= 2) {
        explanation += '<div style="margin-left: 30px; color: #16a34a;">‚Ä¢ Situa√ß√£o favor√°vel: Pouchos oponentes</div>';
      } else if (gameState.opponents <= 4) {
        explanation += '<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ Mesa m√©dia: Equity moderada</div>';
      } else {
        explanation += '<div style="margin-left: 30px; color: #dc2626;">‚Ä¢ Mesa cheia: Equity reduzida</div>';
      }
      
      // 5. Final Equity
      explanation += '<div style="margin-left: 15px; margin-bottom: 8px; margin-top: 15px;"><strong>üéØ Equity Final:</strong></div>';
      explanation += `<div style="margin-left: 30px; color: #f59e0b; font-weight: bold; font-size: 16px;">‚Üí ${equity}% de chance de vit√≥ria</div>`;
      
      document.getElementById('explanation').innerHTML = explanation;
      
      updateDisplay();
      updatePhaseButton();
      saveGame(); // Save after reset to keep cleared history
    }
    
    function advancePhase() {
      if (gameState.showingResult) {
        // Continue to next phase after answering
        gameState.showingResult = false;
        
        if (gameState.phase === 'river') {
          showHandResult();
          return;
        }
        
        // Move to next phase
        nextPhase();
      } else {
        // Direct phase advance (flop/turn/river button)
        if (gameState.phase === 'river') {
          showHandResult();
          return;
        }
        
        nextPhase();
      }
    }
    
    function nextPhase() {
      const availableDeck = createDeck().filter(card => 
        !gameState.usedCards.some(used => used.value === card.value && used.suit === card.suit)
      );
      const shuffledDeck = shuffle(availableDeck);
      
      if (gameState.phase === 'preflop') {
        // Deal flop (3 cards)
        const flopCards = shuffledDeck.slice(0, 3);
        gameState.communityCards = flopCards;
        gameState.usedCards.push(...flopCards);
        gameState.phase = 'flop';
      } else if (gameState.phase === 'flop') {
        // Deal turn (1 card)
        const turnCard = shuffledDeck[0];
        gameState.communityCards.push(turnCard);
        gameState.usedCards.push(turnCard);
        gameState.phase = 'turn';
      } else if (gameState.phase === 'turn') {
        // Deal river (1 card)
        const riverCard = shuffledDeck[0];
        gameState.communityCards.push(riverCard);
        gameState.usedCards.push(riverCard);
        gameState.phase = 'river';
      }
      
      // Recalculate probability for new phase
      gameState.currentProbability = calculateAdvancedProbability(
        gameState.playerCards, 
        gameState.communityCards, 
        gameState.opponents
      );
      
      gameState.correctAnswer = gameState.currentProbability;
      gameState.options = generateOptions(gameState.currentProbability);
      
      updateDisplay();
      updateBeginnerHints();
      updatePhaseButton();
    }
    
    function determineWinner() {
      const results = gameState.allPlayersHands.map(player => {
        const hand = evaluateHand(player.cards, gameState.communityCards);
        return {
          ...player,
          hand: hand,
          handRank: hand.rank,
          handScore: hand.score
        };
      });
      
      // Sort by hand strength (rank first, then score)
      results.sort((a, b) => {
        if (a.handRank !== b.handRank) return b.handRank - a.handRank;
        return b.handScore - a.handScore;
      });
      
      return results[0];
    }
    
    function showHandResult() {
      gameState.showingHandResult = true;
      gameState.handWinner = determineWinner();
      
      const winnerAnnouncement = document.getElementById('winner-announcement');
      const winnerText = document.getElementById('winner-text');
      const winningHandName = document.getElementById('winning-hand-name');
      
      const isPlayerWinner = gameState.handWinner.isPlayer;
      
      winnerAnnouncement.className = `winner-announcement ${isPlayerWinner ? 'player-won' : 'opponent-won'}`;
      
      if (isPlayerWinner) {
        winnerText.innerHTML = 'üèÜ VOC√ä GANHOU! üèÜ';
        // Tournament mode: increase stack
        if (gameState.gameMode === 'torneio') {
          gameState.stackSize += gameState.potSize;
        }
      } else {
        winnerText.innerHTML = `üòî ${gameState.handWinner.name} Ganhou`;
        // Tournament mode: decrease stack
        if (gameState.gameMode === 'torneio') {
          gameState.stackSize -= Math.min(gameState.stackSize, 100);
        }
      }
      
      winningHandName.innerHTML = `${gameState.handWinner.hand.name}`;
      
      updateDisplay();
      
      // Auto advance after showing result
      setTimeout(() => {
        continueToNextHand();
      }, 3000);
    }
    
    function continueToNextHand() {
      // Only increment hand counter when a hand was actually played (not folded)
      gameState.currentHand++;
      
      if (gameState.currentHand > 50) {
        finishGame();
        return;
      }
      
      dealNewHand();
    }
    
    function resetCurrentGame() {
      if (confirm('üîÑ Tem certeza que deseja reiniciar o jogo? Os contadores atuais ser√£o zerados.')) {
        // Reset only current session counters
        gameState.currentHand = 0;
        gameState.score = { correct: 0, total: 0, folded: 0 };
        gameState.streak = 0;
        
        // Reset tournament stats if in tournament mode
        if (gameState.gameMode === 'torneio') {
          gameState.stackSize = 1000;
          gameState.blindLevel = 1;
          gameState.potSize = 150;
        }
        
        // Reset interface states
        gameState.showingResult = false;
        gameState.showingHandResult = false;
        gameState.gameInProgress = false;
        
        // Deal new hand to start fresh
        dealNewHand();
        updateDisplay();
        
        // Show confirmation
        alert('‚úÖ Jogo reiniciado! Contadores zerados.');
        
        // Save the reset state
        saveGame();
      }
    }

    function foldHand() {
      gameState.score.folded++;
      
      // Add fold to history
      gameState.history.unshift({
        hand: gameState.currentHand,
        phase: gameState.phase,
        playerCards: [...gameState.playerCards],
        communityCards: [...gameState.communityCards],
        action: 'FOLD',
        timestamp: new Date()
      });
      
      // Fold doesn't count as a played hand, just deal new cards
      dealNewHand();
    }
    
    function newGame() {
      if (gameState.gameInProgress && !gameState.showingHandResult) {
        if (!confirm('Tem certeza que deseja iniciar uma nova m√£o? O progresso atual ser√° perdido.')) {
          return;
        }
      }
      
      // Just deal new hand without incrementing counter
      dealNewHand();
    }
    
    function finishGame() {
      gameState.totalGames++;
      const finalScore = gameState.score.total > 0 ? 
        (gameState.score.correct / gameState.score.total) * 100 : 0;
      
      let message = `üèÜ Jogo Finalizado!\n\n`;
      message += `Acertos: ${gameState.score.correct}/${gameState.score.total}\n`;
      message += `Precis√£o: ${finalScore.toFixed(1)}%\n`;
      message += `Melhor sequ√™ncia: ${gameState.bestStreak}\n`;
      message += `Folds: ${gameState.score.folded}\n`;
      message += `Conquistas: ${gameState.achievements.length}/${achievementsList.length}`;
      
      if (gameState.gameMode === 'torneio') {
        message += `\nStack final: ${gameState.stackSize}`;
      }
      
      alert(message);
      
      // Reset for new game
      gameState.currentHand = 0; // Will be incremented to 1 on first completed hand
      gameState.score = { correct: 0, total: 0, folded: 0 };
      gameState.streak = 0;
      gameState.stackSize = 1000;
      gameState.blindLevel = 1;
      gameState.potSize = 150;
      gameState.gameInProgress = false;
      
      dealNewHand();
      saveGame();
    }
    
    function setGameMode(mode) {
      gameState.gameMode = mode;
      
      // Update mode buttons
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      // Reset some values for new mode
      if (mode === 'torneio') {
        gameState.stackSize = 1000;
        gameState.blindLevel = 1;
        gameState.potSize = 150;
      }
      
      updateDisplay();
      updateBeginnerHints();
      saveGame();
    }
    
    function generateDetailedExplanation(correctProb, selectedProb) {
      const handStrength = evaluateHand(gameState.playerCards, gameState.communityCards);
      const diff = Math.abs(selectedProb - correctProb);
      const allCards = [...gameState.playerCards, ...gameState.communityCards];
      
      let explanation = '';
      
      // Performance feedback first
      if (diff < 0.03) {
        explanation += '<div style="color: #16a34a; font-weight: bold; margin-bottom: 10px;">üéØ Excelente! Estimativa muito precisa!</div>';
      } else if (diff < 0.08) {
        explanation += '<div style="color: #f59e0b; font-weight: bold; margin-bottom: 10px;">üëç Boa estimativa! Pequena diferen√ßa.</div>';
      } else {
        explanation += '<div style="color: #dc2626; font-weight: bold; margin-bottom: 10px;">‚ö†Ô∏è Estimativa distante. Vamos analisar:</div>';
      }
      
      // Hand strength analysis
      explanation += '<div style="margin-bottom: 8px;"><strong>üÉè An√°lise da M√£o:</strong></div>';
      explanation += `<div style="margin-left: 15px; margin-bottom: 10px;">‚Ä¢ Voc√™ tem: <strong>${handStrength.name}</strong></div>`;
      
      if (gameState.phase === 'preflop') {
        explanation += getPreflopAnalysis();
      } else {
        explanation += getPostflopAnalysis();
      }
      
      // Opponent impact
      explanation += '<div style="margin: 15px 0 8px 0;"><strong>üë• Impacto dos Oponentes:</strong></div>';
      explanation += `<div style="margin-left: 15px; margin-bottom: 10px;">‚Ä¢ ${gameState.opponents} oponentes na mesa</div>`;
      
      const opponentPenalty = gameState.phase === 'preflop' ? 
        getOpponentAdjustment() : Math.pow(0.88, gameState.opponents - 1);
      
      explanation += `<div style="margin-left: 15px; color: #f59e0b;">‚Üí Redu√ß√£o de equity: ${((1 - opponentPenalty) * 100).toFixed(1)}%</div>`;
      
      // Phase specific analysis with dynamic changes
      explanation += '<div style="margin: 15px 0 8px 0;"><strong>‚è∞ Evolu√ß√£o da M√£o:</strong></div>';
      explanation += `<div style="margin-left: 15px; margin-bottom: 10px;">‚Ä¢ Fase atual: <strong>${phaseNames[gameState.phase]}</strong></div>`;
      
      if (gameState.phase === 'preflop') {
        explanation += '<div style="margin-left: 15px;">‚Üí Probabilidade baseada apenas nas suas duas cartas iniciais</div>';
      } else {
        explanation += '<div style="margin-left: 15px;">‚Üí Probabilidade atualizada baseada nas cartas comunit√°rias</div>';
        
        // Analyze how the hand changed from preflop
        const handImprovement = analyzeHandImprovement();
        if (handImprovement) {
          explanation += `<div style="margin-left: 15px; color: #16a34a;">‚Üí ${handImprovement}</div>`;
        }
        
        // Board texture warnings
        const threats = analyzeBoardThreats(gameState.communityCards);
        if (threats.flushPossible) {
          explanation += '<div style="margin-left: 15px; color: #dc2626;">‚ö†Ô∏è Flush poss√≠vel na mesa!</div>';
        }
        if (threats.straightPossible) {
          explanation += '<div style="margin-left: 15px; color: #dc2626;">‚ö†Ô∏è Sequ√™ncia poss√≠vel na mesa!</div>';
        }
        if (threats.pairedBoard) {
          explanation += '<div style="margin-left: 15px; color: #f59e0b;">‚ö†Ô∏è Mesa pareada - full house poss√≠vel!</div>';
        }
      }
      
      // Calculation breakdown with professional structure
      explanation += '<div style="margin: 15px 0 8px 0;"><strong>üî¨ An√°lise Profissional:</strong></div>';
      
      // 1. Blockers Analysis
      if (gameState.phase === 'preflop') {
        const blockerAnalysis = analyzePreflopBlockers();
        explanation += '<div style="margin-left: 15px; margin-bottom: 8px;"><strong>üõ°Ô∏è Blockers:</strong></div>';
        explanation += blockerAnalysis;
      } else {
        const blockerAnalysis = calculateBlockers(gameState.playerCards, gameState.communityCards);
        explanation += '<div style="margin-left: 15px; margin-bottom: 8px;"><strong>üõ°Ô∏è Blockers:</strong></div>';
        
        if (blockerAnalysis.premiumBlockers > 0) {
          explanation += `<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ ${blockerAnalysis.premiumBlockers} cartas premium bloqueadas (J+)</div>`;
        }
        
        Object.entries(blockerAnalysis.flushBlockers).forEach(([suit, count]) => {
          if (count > 0) {
            explanation += `<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ ${count} carta(s) de ${suit} bloqueada(s) (reduz flush draws)</div>`;
          }
        });
        
        Object.entries(blockerAnalysis.pairBlockers).forEach(([value, count]) => {
          if (count > 0) {
            const cardName = getCardName(parseInt(value));
            explanation += `<div style="margin-left: 30px; color: #f59e0b;">‚Ä¢ ${count} ${cardName}(s) bloqueada(s) (reduz sets/pares)</div>`;
          }
        });
        
        if (blockerAnalysis.premiumBlockers === 0 && Object.keys(blockerAnalysis.flushBlockers).length === 0) {
          explanation += '<div style="margin-left: 30px; color: #9ca3af;">‚Ä¢ Sem blockers significativos</div>';
        }
      }
      
      // 2. Outs Analysis (post-flop only)
      if (gameState.communityCards.length >= 3) {
        const outsAnalysis = calculateOutsWithBlockers(gameState.playerCards, gameState.communityCards, []);
        explanation += '<div style="margin-left: 15px; margin-bottom: 8px; margin-top: 10px;"><strong>üéØ Outs Dispon√≠veis:</strong></div>';
        
        if (outsAnalysis.total === 0) {
          explanation += '<div style="margin-left: 30px; color: #9ca3af;">‚Ä¢ Nenhum out direto para melhorar</div>';
        } else {
          if (outsAnalysis.flush > 0) {
            explanation += `<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ ${outsAnalysis.flush} outs para flush</div>`;
          }
          if (outsAnalysis.straight > 0) {
            explanation += `<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ ${outsAnalysis.straight} outs para sequ√™ncia</div>`;
          }
          if (outsAnalysis.pair > 0) {
            explanation += `<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ ${outsAnalysis.pair} outs para par</div>`;
          }
          if (outsAnalysis.trips > 0) {
            explanation += `<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ ${outsAnalysis.trips} outs para trinca/set</div>`;
          }
          if (outsAnalysis.fullHouse > 0) {
            explanation += `<div style="margin-left: 30px; color: #3b82f6;">‚Ä¢ ${outsAnalysis.fullHouse} outs para full house</div>`;
          }
          
          explanation += `<div style="margin-left: 30px; color: #16a34a; font-weight: bold;">‚Ä¢ Total: ${outsAnalysis.total} outs</div>`;
        }
      }
      
      // 3. Expert Recommendation
      explanation += '<div style="margin-left: 15px; margin-bottom: 8px; margin-top: 10px;"><strong>üß† Recomenda√ß√£o dos Especialistas:</strong></div>';
      const expertAdvice = getExpertRecommendation(correctProb, gameState.phase);
      explanation += expertAdvice;
      
      // 4. Opponent Count
      explanation += '<div style="margin-left: 15px; margin-bottom: 8px; margin-top: 10px;"><strong>üë• Situa√ß√£o da Mesa:</strong></div>';
      explanation += `<div style="margin-left: 30px;">‚Ä¢ Voc√™ vs <strong>${gameState.opponents} oponentes</strong></div>`;
      
      const opponentImpact = getOpponentImpactDescription(gameState.opponents);
      explanation += opponentImpact;
      
      // 5. Final Equity
      explanation += '<div style="margin-left: 15px; margin-bottom: 8px; margin-top: 15px;"><strong>üéØ Equity Final:</strong></div>';
      explanation += `<div style="margin-left: 30px; color: #f59e0b; font-weight: bold; font-size: 16px;">‚Üí ${Math.round(correctProb * 100)}% de chance de vit√≥ria</div>`;
      
      return explanation;
    }
    
    function getPreflopAnalysis() {
      const card1 = getCardValue(gameState.playerCards[0].value);
      const card2 = getCardValue(gameState.playerCards[1].value);
      const suit1 = gameState.playerCards[0].suit;
      const suit2 = gameState.playerCards[1].suit;
      
      const isPair = card1 === card2;
      const isSuited = suit1 === suit2;
      const highCard = Math.max(card1, card2);
      const lowCard = Math.min(card1, card2);
      
      let analysis = '';
      
      if (isPair) {
        if (card1 >= 11) {
          analysis += '<div style="margin-left: 15px; color: #16a34a;">‚Üí Par premium! Uma das melhores m√£os iniciais.</div>';
        } else if (card1 >= 8) {
          analysis += '<div style="margin-left: 15px; color: #f59e0b;">‚Üí Par m√©dio. Bom para ver flop, mas cuidado com overcards.</div>';
        } else {
          analysis += '<div style="margin-left: 15px; color: #dc2626;">‚Üí Par baixo. Vulner√°vel, mas pode fazer set.</div>';
        }
      } else if (highCard === 14 && lowCard >= 10) {
        analysis += '<div style="margin-left: 15px; color: #16a34a;">‚Üí √Ås com carta alta! Excelente m√£o inicial.</div>';
        if (isSuited) analysis += '<div style="margin-left: 15px; color: #3b82f6;">‚Üí Suited adiciona ~5% de equity extra.</div>';
      } else if (highCard >= 13 && lowCard >= 10) {
        analysis += '<div style="margin-left: 15px; color: #16a34a;">‚Üí Duas cartas altas! Boa m√£o para abrir.</div>';
        if (isSuited) analysis += '<div style="margin-left: 15px; color: #3b82f6;">‚Üí Suited melhora significativamente.</div>';
      } else if (Math.abs(highCard - lowCard) <= 1 && highCard >= 9) {
        analysis += '<div style="margin-left: 15px; color: #f59e0b;">‚Üí Conectores! Potencial para straights.</div>';
        if (isSuited) analysis += '<div style="margin-left: 15px; color: #3b82f6;">‚Üí Suited connectors s√£o muito jog√°veis.</div>';
      } else if (highCard === 14) {
        analysis += '<div style="margin-left: 15px; color: #f59e0b;">‚Üí √Ås com carta baixa. Domina√ß√£o reversa √© um risco.</div>';
      } else {
        analysis += '<div style="margin-left: 15px; color: #dc2626;">‚Üí M√£o fraca. Fold na maioria das situa√ß√µes.</div>';
      }
      
      return analysis;
    }
    
    function getPostflopAnalysis() {
      const handStrength = evaluateHand(gameState.playerCards, gameState.communityCards);
      let analysis = '';
      
      switch (handStrength.rank) {
        case 10:
        case 9:
        case 8:
          analysis += '<div style="margin-left: 15px; color: #16a34a;">‚Üí Nuts ou quase nuts! Aposte para valor m√°ximo.</div>';
          break;
        case 7:
          analysis += '<div style="margin-left: 15px; color: #16a34a;">‚Üí Full house! M√£o monstro, dif√≠cil de ser batida.</div>';
          break;
        case 6:
          analysis += '<div style="margin-left: 15px; color: #16a34a;">‚Üí Flush! Muito forte, mas cuidado com full houses.</div>';
          break;
        case 5:
          analysis += '<div style="margin-left: 15px; color: #16a34a;">‚Üí Straight! Boa m√£o, mas cuidado com flushes.</div>';
          break;
        case 4:
          analysis += '<div style="margin-left: 15px; color: #f59e0b;">‚Üí Trinca! Boa m√£o, mas vulner√°vel a draws.</div>';
          break;
        case 3:
          analysis += '<div style="margin-left: 15px; color: #f59e0b;">‚Üí Dois pares! M√£o decente, cuidado com draws.</div>';
          break;
        case 2:
          const pairValue = getPairValue(gameState.playerCards, gameState.communityCards);
          if (pairValue >= 11) {
            analysis += '<div style="margin-left: 15px; color: #f59e0b;">‚Üí Par alto! Pode ser boa para value bet.</div>';
          } else {
            analysis += '<div style="margin-left: 15px; color: #dc2626;">‚Üí Par baixo/m√©dio. Cuidado com overcards.</div>';
          }
          break;
        default:
          analysis += '<div style="margin-left: 15px; color: #dc2626;">‚Üí Carta alta apenas. Precisa melhorar para ganhar.</div>';
      }
      
      return analysis;
    }
    
    function analyzeHandImprovement() {
      const playerCards = gameState.playerCards;
      const communityCards = gameState.communityCards;
      
      if (communityCards.length === 0) return null;
      
      // Check what we had preflop
      const card1 = getCardValue(playerCards[0].value);
      const card2 = getCardValue(playerCards[1].value);
      const isPreflopPair = card1 === card2;
      const currentHand = evaluateHand(playerCards, communityCards);
      
      if (currentHand.rank >= 8) {
        return "üöÄ M√£o monstro formada! Equity disparou para o topo!";
      }
      else if (currentHand.rank === 7) {
        return "üè† Full house! Equity alt√≠ssima - quase nuts!";
      }
      else if (currentHand.rank === 6) {
        return "üíé Flush completado! M√£o muito forte!";
      }
      else if (currentHand.rank === 5) {
        return "‚û°Ô∏è Sequ√™ncia formada! Boa m√£o, cuidado com flushes!";
      }
      else if (currentHand.rank === 4) {
        if (isPreflopPair) {
          return "üéØ SET! M√£o melhorou drasticamente - equity explodiu!";
        } else {
          return "‚≠ê Trinca formada! Equity aumentou muito!";
        }
      }
      else if (currentHand.rank === 3) {
        return "üë• Dois pares! M√£o melhorou significativamente!";
      }
      else if (currentHand.rank === 2) {
        if (!isPreflopPair) {
          return "üìà Par formado! Melhorou bastante do high card!";
        } else {
          return "‚öñÔ∏è Manteve o par, mas equity mudou pelo board texture";
        }
      }
      
      // Check for draws using new system
      const remainingDeck = getRemainingDeck([...playerCards, ...communityCards]);
      const outs = calculateOutsWithBlockers(playerCards, communityCards, remainingDeck);
      const blockers = calculateBlockers(playerCards, communityCards);
      
      if (outs.total > 8) {
        return `üåü Muitos draws! ${outs.total} outs + blockers = equity boa`;
      } else if (outs.total > 4) {
        return `üé® Alguns draws dispon√≠veis: ${outs.total} outs para melhorar`;
      }
      
      // Consider blockers impact
      if (blockers.premiumBlockers > 1) {
        return "üõ°Ô∏è Bons blockers! Reduz m√£os premium dos oponentes";
      }
      
      return "üìâ Board n√£o ajudou - equity provavelmente diminuiu";
    }



    function checkAchievements(isCorrect) {
      const newAchievements = [];
      
      // First win
      if (isCorrect && gameState.score.correct === 1 && !gameState.achievements.includes('first_win')) {
        newAchievements.push('first_win');
      }
      
      // Streaks
      if (gameState.streak >= 5 && !gameState.achievements.includes('streak_5')) {
        newAchievements.push('streak_5');
      }
      if (gameState.streak >= 10 && !gameState.achievements.includes('streak_10')) {
        newAchievements.push('streak_10');
      }
      
      // Folder
      if (gameState.score.folded >= 10 && !gameState.achievements.includes('folder')) {
        newAchievements.push('folder');
      }
      
      // River master
      const riverCorrect = gameState.phaseStats.river.correct;
      if (riverCorrect >= 10 && !gameState.achievements.includes('river_master')) {
        newAchievements.push('river_master');
      }
      
      // Perfectionist (95% in 20 hands)
      if (gameState.score.total >= 20) {
        const accuracy = (gameState.score.correct / gameState.score.total) * 100;
        if (accuracy >= 95 && !gameState.achievements.includes('perfectionist')) {
          newAchievements.push('perfectionist');
        }
        if (accuracy >= 90 && gameState.score.total >= 30 && !gameState.achievements.includes('poker_master')) {
          newAchievements.push('poker_master');
        }
      }
      
      // Analyzer (based on total questions answered, not just current hand counter)
      if (gameState.score.total >= 50 && !gameState.achievements.includes('analyzer')) {
        newAchievements.push('analyzer');
      }
      
      // Tournament player (based on current hand in tournament mode)
      if (gameState.gameMode === 'torneio' && gameState.score.total >= 10 && !gameState.achievements.includes('tournament_player')) {
        newAchievements.push('tournament_player');
      }
      
      // Expert mode (based on total questions in expert mode)
      if (gameState.gameMode === 'especialista' && gameState.score.total >= 50 && !gameState.achievements.includes('expert_mode')) {
        newAchievements.push('expert_mode');
      }
      
      // Show notifications for new achievements
      newAchievements.forEach(achievementId => {
        if (!gameState.achievements.includes(achievementId)) {
          gameState.achievements.push(achievementId);
          showAchievementNotification(achievementId);
        }
      });
    }
    
    function showAchievementNotification(achievementId) {
      const achievement = achievementsList.find(a => a.id === achievementId);
      if (!achievement) return;
      
      const notification = document.getElementById('achievement-notification');
      const text = document.getElementById('achievement-text');
      
      text.innerHTML = `<strong>${achievement.icon} ${achievement.name}</strong><br>${achievement.description}`;
      notification.style.display = 'block';
      
      setTimeout(() => {
        notification.style.display = 'none';
      }, 4000);
    }
    
    // Tab system
    function showTab(tabName) {
      // Hide all tabs
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.add('hidden');
      });
      
      // Remove active class from all tab buttons
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Show selected tab
      document.getElementById(tabName + '-tab').classList.remove('hidden');
      
      // Add active class to clicked tab
      event.target.classList.add('active');
      
      // Update content based on tab
      if (tabName === 'stats') {
        updateStatsTab();
      } else if (tabName === 'history') {
        updateHistoryTab();
      } else if (tabName === 'achievements') {
        updateAchievementsTab();
      } else if (tabName === 'ranking') {
        updateRankingTab();
      }
    }
    
    function updateStatsTab() {
      document.getElementById('total-games').textContent = gameState.totalGames;
      document.getElementById('best-streak').textContent = gameState.bestStreak;
      document.getElementById('total-folds').textContent = gameState.score.folded;
      
      const avgAccuracy = gameState.score.total > 0 ? 
        Math.round((gameState.score.correct / gameState.score.total) * 100) : 0;
      document.getElementById('avg-accuracy').textContent = `${avgAccuracy}%`;
      
      // Update phase chart
      const phaseChart = document.getElementById('phase-chart');
      const phases = ['preflop', 'flop', 'turn', 'river'];
      const phaseLabels = ['Pr√©-Flop', 'Flop', 'Turn', 'River'];
      
      phaseChart.innerHTML = phases.map((phase, index) => {
        const stats = gameState.phaseStats[phase];
        const accuracy = stats.total > 0 ? (stats.correct / stats.total) * 100 : 0;
        const height = Math.max(5, accuracy);
        
        return `
          <div class="chart-bar" style="height: ${height}%;" title="${phaseLabels[index]}: ${accuracy.toFixed(1)}%">
            <div class="chart-label">${phaseLabels[index]}</div>
          </div>
        `;
      }).join('');
      
      // Update hand type stats
      const handTypeContainer = document.getElementById('hand-type-stats');
      const handTypes = Object.entries(gameState.handTypeStats);
      
      if (handTypes.length === 0) {
        handTypeContainer.innerHTML = '<p style="text-align: center; color: #9ca3af;">Jogue mais m√£os para ver estat√≠sticas por tipo</p>';
      } else {
        const handTypeHTML = handTypes.map(([handType, stats]) => {
          const accuracy = Math.round((stats.correct / stats.total) * 100);
          const colorClass = accuracy >= 80 ? 'color: #16a34a' : accuracy >= 60 ? 'color: #f59e0b' : 'color: #dc2626';
          
          return `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 8px;">
              <span>${handType}</span>
              <span style="${colorClass}; font-weight: bold;">
                ${accuracy}% (${stats.total})
              </span>
            </div>
          `;
        }).join('');
        
        handTypeContainer.innerHTML = handTypeHTML;
      }
    }
    
    function updateHistoryTab() {
      const historyContainer = document.getElementById('history-list');
      
      if (gameState.history.length === 0) {
        historyContainer.innerHTML = '<p style="text-align: center; color: #9ca3af;">Nenhuma m√£o no hist√≥rico atual. Jogue algumas m√£os ou inicie um novo jogo para ver o hist√≥rico detalhado.</p>';
        return;
      }
      
      const historyHTML = gameState.history.slice(0, 20).map((hand) => {
        if (hand.action === 'FOLD') {
          return `
            <div style="background: rgba(107, 114, 128, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 1px solid rgba(255,255,255,0.1);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <strong>M√£o #${hand.hand} - ${phaseNames[hand.phase]}</strong>
                <span style="font-size: 20px;">üö´</span>
              </div>
              <div style="font-size: 14px;">
                <strong>A√ß√£o:</strong> FOLD | 
                <strong>Suas cartas:</strong> ${hand.playerCards.map(c => `${c.value}${c.suit}`).join(' ')} |
                <strong>Mesa:</strong> ${hand.communityCards.map(c => `${c.value}${c.suit}`).join(' ') || 'Pr√©-flop'}
              </div>
            </div>
          `;
        }
        
        const resultIcon = hand.isCorrect ? '‚úÖ' : '‚ùå';
        const bgColor = hand.isCorrect ? 'rgba(22, 163, 74, 0.1)' : 'rgba(220, 38, 38, 0.1)';
        
        return `
          <div style="background: ${bgColor}; padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 1px solid rgba(255,255,255,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
              <strong>M√£o #${hand.hand} - ${phaseNames[hand.phase]}</strong>
              <span style="font-size: 20px;">${resultIcon}</span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px; margin-bottom: 10px;">
              <div><strong>Suas cartas:</strong> ${hand.playerCards.map(c => `${c.value}${c.suit}`).join(' ')}</div>
              <div><strong>Mesa:</strong> ${hand.communityCards.map(c => `${c.value}${c.suit}`).join(' ') || 'Pr√©-flop'}</div>
              <div><strong>Sua estimativa:</strong> ${Math.round(hand.estimated * 100)}%</div>
              <div><strong>Probabilidade real:</strong> ${Math.round(hand.actual * 100)}%</div>
            </div>
            <div style="font-size: 14px;">
              <strong>Tipo de m√£o:</strong> ${hand.handType} | 
              <strong>Diferen√ßa:</strong> ${Math.abs(Math.round((hand.estimated - hand.actual) * 100))}%
            </div>
          </div>
        `;
      }).join('');
      
      historyContainer.innerHTML = historyHTML;
    }
    
    function updateAchievementsTab() {
      const achievementsContainer = document.getElementById('achievements-grid');
      
      const achievementsHTML = achievementsList.map((achievement) => {
        const unlocked = gameState.achievements.includes(achievement.id);
        const cardClass = unlocked ? 'unlocked' : 'locked';
        
        return `
          <div class="achievement-card ${cardClass}">
            <div style="font-size: 48px; margin-bottom: 15px;">${achievement.icon}</div>
            <div style="font-weight: bold; font-size: 18px; margin-bottom: 10px;">
              ${achievement.name}
            </div>
            <div style="font-size: 14px; margin-bottom: 15px;">
              ${achievement.description}
            </div>
            ${unlocked ? 
              '<div style="color: #16a34a; font-weight: bold;">üéâ DESBLOQUEADO!</div>' :
              '<div style="color: #6b7280;">üîí Bloqueado</div>'
            }
          </div>
        `;
      }).join('');
      
      achievementsContainer.innerHTML = achievementsHTML;
    }
    
    function updateRankingTab() {
      const rankingContainer = document.getElementById('ranking-list');
      
      // Add player to ranking if they have games
      const playerRanking = [...rankings];
      if (gameState.totalGames > 0) {
        const playerAccuracy = gameState.score.total > 0 ? 
          (gameState.score.correct / gameState.score.total) * 100 : 0;
        
        playerRanking.push({
          name: "Voc√™",
          score: playerAccuracy,
          games: gameState.totalGames,
          isPlayer: true
        });
      }
      
      // Sort by score
      playerRanking.sort((a, b) => b.score - a.score);
      
      const rankingHTML = playerRanking.slice(0, 10).map((entry, index) => {
        const position = index + 1;
        const medalColor = position <= 3 ? '#f59e0b' : '#6b7280';
        const bgColor = entry.isPlayer ? 'rgba(245, 158, 11, 0.1)' : 'rgba(0, 0, 0, 0.3)';
        
        return `
          <div style="background: ${bgColor}; padding: 15px; border-radius: 10px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="display: flex; align-items: center; gap: 15px;">
                <span style="color: ${medalColor}; font-size: 20px; font-weight: bold;">#${position}</span>
                <span style="font-weight: bold; font-size: 16px;">${entry.name}</span>
              </div>
              <div style="text-align: right;">
                <div style="font-weight: bold; color: #f59e0b;">${entry.score.toFixed(1)}%</div>
                <div style="font-size: 12px; color: #9ca3af;">${entry.games} jogos</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      rankingContainer.innerHTML = rankingHTML;
    }
    
    function resetPersonalStats() {
      if (confirm('‚ö†Ô∏è Tem certeza que deseja resetar todas suas estat√≠sticas? Esta a√ß√£o n√£o pode ser desfeita.')) {
        gameState = {
          ...gameState,
          score: { correct: 0, total: 0, folded: 0 },
          streak: 0,
          bestStreak: 0,
          totalGames: 0,
          history: [],
          achievements: [],
          phaseStats: {
            preflop: { correct: 0, total: 0 },
            flop: { correct: 0, total: 0 },
            turn: { correct: 0, total: 0 },
            river: { correct: 0, total: 0 }
          },
          handTypeStats: {}
        };
        
        saveGame();
        updateDisplay();
        alert('‚úÖ Estat√≠sticas resetadas com sucesso!');
      }
    }
    
    // Local Storage functions
    function saveGame() {
      try {
        localStorage.setItem('poker_trainer_complete', JSON.stringify(gameState));
      } catch (e) {
        console.log('Could not save game data');
      }
    }
    
    function loadGame() {
      try {
        const saved = localStorage.getItem('poker_trainer_complete');
        if (saved) {
          const savedState = JSON.parse(saved);
          gameState = { ...gameState, ...savedState };
        }
      } catch (e) {
        console.log('Could not load game data');
      }
    }
    
    // PWA Installation
    let deferredPrompt;
    
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      
      const installBtn = document.getElementById('install-btn');
      installBtn.style.display = 'block';
      
      installBtn.addEventListener('click', async () => {
        if (!deferredPrompt) return;
        
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        
        if (outcome === 'accepted') {
          installBtn.style.display = 'none';
        }
        
        deferredPrompt = null;
      });
    });
    
    window.addEventListener('appinstalled', () => {
      document.getElementById('install-btn').style.display = 'none';
    });
    
    // Initialize game
    function initGame() {
      loadGame();
      dealNewHand();
      updateDisplay();
      updateBeginnerHints();
      updatePhaseButton();
      console.log('üéØ Poker Trainer Completo carregado com sucesso!');
    }
    
    // Start the game when page loads
    document.addEventListener('DOMContentLoaded', initGame);
    
    // Make functions available globally for onclick handlers
    window.resetCurrentGame = resetCurrentGame;
    window.foldHand = foldHand;
    window.advancePhase = advancePhase;
    window.selectOption = selectOption;
    window.continueToNextHand = continueToNextHand;
    window.setGameMode = setGameMode;
    window.showTab = showTab;
    window.resetPersonalStats = resetPersonalStats;
  </script>
  
  <!-- Simple PWA Manifest inline -->
  <script>
    const manifestData = {
      "name": "Poker Probability Trainer - Completo",
      "short_name": "PokerTrainer",
      "description": "Treinador profissional de probabilidades de poker",
      "start_url": "/",
      "display": "standalone",
      "background_color": "#1f2937",
      "theme_color": "#059669",
      "icons": [
        {
          "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='bg' x1='0%' y1='0%' x2='100%' y2='100%'><stop offset='0%' style='stop-color:%23059669;stop-opacity:1' /><stop offset='100%' style='stop-color:%23047857;stop-opacity:1' /></linearGradient></defs><rect width='100' height='100' fill='url(%23bg)' rx='20'/><text x='50' y='35' font-size='20' text-anchor='middle' fill='white' font-weight='bold'>üéØ</text><text x='50' y='55' font-size='16' text-anchor='middle' fill='white'>POKER</text><text x='50' y='75' font-size='12' text-anchor='middle' fill='%23f59e0b'>TRAINER</text></svg>",
          "sizes": "192x192",
          "type": "image/svg+xml"
        }
      ]
    };
    
    const blob = new Blob([JSON.stringify(manifestData)], {type: 'application/json'});
    const manifestURL = URL.createObjectURL(blob);
    
    const link = document.createElement('link');
    link.rel = 'manifest';
    link.href = manifestURL;
    document.head.appendChild(link);
  </script>
</body>
</html>